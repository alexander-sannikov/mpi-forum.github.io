<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-one-side/one-side-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi4-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi41-report-html.idx -basedef mpi4defs.txt -o mpi41-report.tex mpi-report.tex 
-->
<title>Examples</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h1><span id="Node342">13.8. Examples</span></h1>
<a href="node341.htm#Node341"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node306.htm#Node306"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node343.htm#Node343"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node306.htm#Node306"> One-Sided Communications</a>
<b>Next: </b><a href="node343.htm#Node343"> External Interfaces</a>
<b>Previous: </b><a href="node341.htm#Node341"> Registers and Compiler Optimizations</a>
<p>
  
<P> 
<br><b> Example</b>  
  
The following example shows a generic loosely synchronous, iterative  
code, using <font face="sans-serif"> MPI_FENCE</font> for synchronization.  The window at each <font face="sans-serif"> MPI</font> process  
consists of array <tt>A</tt>, which contains the origin and target buffers of  
the  
put operations.  
<P> 
<P><img width=766 height=225 src="img391.gif" alt="Image file"><P>
The same code could be written with get rather than put.  Note that,  
during the communication phase, each  
window is concurrently read  (as origin buffer of puts) and written  
(as target buffer of puts).  This is OK, provided that there is no  
overlap between the target buffer of a put and another communication   
buffer.  
  
<P> 
<br><b> Example</b>  
  
Same generic example, with more computation/communication overlap.  We  
assume that the update phase is broken into two  
subphases: the first,   
where the ``boundary,'' which is involved in communication, is updated, and  
the second, where the ``core,'' which neither  
uses nor provides   
communicated data, is updated.  
<P><img width=742 height=250 src="img392.gif" alt="Image file"><P>
The get communication can be concurrent with the core update, since  
they do not access the same locations, and the local update of the  
origin buffer by the get operation can be concurrent with the local update  
of the core by the <tt>update_core</tt> call.  In order to get similar  
overlap with put communication we would need to use separate windows  
for the core and for the boundary.  
This is required   
because we do not allow local stores to be concurrent with puts  
on the same, or on overlapping, windows.  
  
<P> 
<br><b> Example</b>  
Same code as in Example <a href="node342.htm#Node342">Examples</a>,  
rewritten using post-start-complete-wait.  
<P><img width=729 height=275 src="img393.gif" alt="Image file"><P>
  
<P> 
<br><b> Example</b>  
Same example, with post-start-complete-wait, as in Example <a href="node342.htm#Node342">Examples</a>.  
<P><img width=729 height=299 src="img394.gif" alt="Image file"><P>
  
<P> 
<br><b> Example</b>  
A checkerboard, or double buffer  communication pattern, that allows  
more computation/communication overlap.  Array <tt>A0</tt> is updated  
using values of array <tt>A1</tt>, and vice versa.  We assume that communication is symmetric: if process A gets data from process B, then process B gets data from process A.  Window <tt>wini</tt> consists of array <tt>Ai</tt>.  
<P><img width=881 height=798 src="img395.gif" alt="Image file"><P>
An <font face="sans-serif"> MPI</font> process posts the local window associated with  
<tt>win0</tt> before it completes <font face="sans-serif"> RMA</font> accesses to  
the remote windows associated with <tt>win1</tt>.  
When the call to <font face="sans-serif"> MPI_WIN_WAIT</font> on <tt>win1</tt>  
returns, then all neighbors of the calling <font face="sans-serif"> MPI</font> process have posted the  
windows associated with <tt>win0</tt>. Conversely, when the   
call to <font face="sans-serif"> MPI_WIN_WAIT</font> on <tt>win0</tt> returns, then all neighbors of the calling <font face="sans-serif"> MPI</font> process  
have posted the windows associated with <tt>win1</tt>.  
Therefore, the <font face="sans-serif"> MPI_MODE_NOCHECK</font> option can be used with the calls to  
<font face="sans-serif"> MPI_WIN_START</font>.  
<P> 
Put operations can be used, instead of get operations, if the area of array  
<tt>A0</tt> (resp. <tt>A1</tt>) used by <tt>update(A1, A0)</tt>  
(resp. <tt>update(A0, A1)</tt>) is disjoint from the area  
modified by the <font face="sans-serif"> RMA</font> operation.  On some systems, a put operation may be  
more efficient than a get operation, as it requires information exchange  
only in one direction.  
<P> 
  
<P> 
In the next several examples, for conciseness, the expression  
  
<P><img width=330 height=17 src="img396.gif" alt="Image file"><P>
  
means to perform a get-accumulate operation with the result  
buffer (given by <font face="sans-serif"> result_addr</font> in the description of  
<font face="sans-serif"> MPI_GET_ACCUMULATE</font>) on the left side of the  
assignment, in   
this case, <font face="sans-serif"> z</font>.  This format is also used with  
<font face="sans-serif"> MPI_COMPARE_AND_SWAP</font> and <font face="sans-serif"> MPI_COMM_SIZE</font>.  
Process B<i>...</i> refers to any process other than A.  
<P> 
<br><b> Example</b>  
The following example implements a naive, nonscalable counting  
semaphore.  The example demonstrates the use of  
<font face="sans-serif"> MPI_WIN_SYNC</font> to manipulate the public copy of <tt>X</tt>, as well  
as <font face="sans-serif"> MPI_WIN_FLUSH</font> to complete operations without closing the  
access epoch opened with <font face="sans-serif"> MPI_WIN_LOCK_ALL</font>.  To avoid the  
rules regarding synchronization of the public and private copies of  
windows, <font face="sans-serif"> MPI_ACCUMULATE</font> and <font face="sans-serif"> MPI_GET_ACCUMULATE</font>  
are used to write to or read from the local public copy.  
  
<P><img width=893 height=416 src="img397.gif" alt="Image file"><P>
  
  
<P> 
<br><b> Example</b>  
Implementing a critical region between two <font face="sans-serif"> MPI</font> processes (Peterson's  
algorithm).  Despite their appearance in the  
following example, <font face="sans-serif"> MPI_WIN_LOCK_ALL</font> and  
<font face="sans-serif"> MPI_WIN_UNLOCK_ALL</font> are not collective calls, but it is  
frequently useful to open shared access epochs to all <font face="sans-serif"> MPI</font> processes from  
all other <font face="sans-serif"> MPI</font> processes in a window.  Once the access epochs are  
opened, accumulate operations as well as flush and sync  
synchronization can be used to read from or write to the  
public copy of the window.  
  
<P><img width=881 height=566 src="img398.gif" alt="Image file"><P>
  
  
<P> 
<br><b> Example</b>  
Implementing a critical region between multiple <font face="sans-serif"> MPI</font> processes with compare  
and swap.  The call to <font face="sans-serif"> MPI_WIN_SYNC</font> is necessary on  
Process A after local initialization of <tt>A</tt> to guarantee the public copy  
has been updated with the initialization value found in the private  
copy.  It would also be valid to call <font face="sans-serif"> MPI_ACCUMULATE</font> with  
<font face="sans-serif"> MPI_REPLACE</font> to directly initialize the public copy.  A call  
to <font face="sans-serif"> MPI_WIN_FLUSH</font> would be necessary to assure <tt>A</tt> in the  
public copy of Process A had been updated before the barrier.  
  
<P><img width=905 height=342 src="img399.gif" alt="Image file"><P>
  
  
<P> 
<br><b> Example</b>The following example demonstrates the proper synchronization in the  
unified memory model when a data transfer is implemented with load and  
store accesses in the case of windows in <em> shared memory</em> (instead of using <font face="sans-serif"> MPI_PUT</font> or  
<font face="sans-serif"> MPI_GET</font>) and the synchronization between <font face="sans-serif"> MPI</font> processes is performed using  
point-to-point communication. The synchronization between <font face="sans-serif"> MPI</font> processes  
must be supplemented with a memory synchronization through calls to  
<font face="sans-serif"> MPI_WIN_SYNC</font>, which act locally as a processor-memory barrier. In  
Fortran, if <font face="sans-serif"> MPI_ASYNC_PROTECTS_NONBLOCKING</font> is  
<tt>.FALSE.</tt>  
or the variable <tt>X</tt> is not declared as <tt> ASYNCHRONOUS</tt>,  
reordering of the accesses to the  
variable <tt>X</tt> must be prevented with <font face="sans-serif"> MPI_F_SYNC_REG</font>  
operations. (No equivalent function is needed in C.)  
<P> 
The variable <tt>X</tt> is contained within a <em> shared memory window</em> and <tt>X</tt>  
corresponds to the same memory location at both processes. The first call to  
<font face="sans-serif"> MPI_WIN_SYNC</font> performed by process A ensures completion of  
the load/store accesses issued by process A. The first call to <font face="sans-serif"> MPI_WIN_SYNC</font>  
performed by process B ensures that process A's updates to <tt>X</tt>  
are visible to process B.  
Similarly, the second call to <font face="sans-serif"> MPI_WIN_SYNC</font> on each process ensures  
correct ordering of the point-to-point communication and thus that the load/store  
operations on process B have completed before any subsequent  
load/store accesses to the variable <tt>X</tt> in process A.  
<P> 
  
<P><img width=744 height=567 src="img400.gif" alt="Image file"><P>
  
  
<P> 
<br><b> Example</b>  
The following example shows how request-based operations can be used  
to overlap communication with computation.  Each <font face="sans-serif"> MPI</font> process fetches,  
processes, and writes the result for <tt>NSTEPS</tt> chunks of data.  Instead  
of a single buffer, <tt>M</tt> local buffers are used to allow up to <tt>M</tt>  
communication operations to overlap with computation.   
<P> 
<P><img width=891 height=698 src="img401.gif" alt="Image file"><P>
  
<P> 
<br><b> Example</b>  
The following example constructs a distributed shared linked list using dynamic  
windows.  Initially process 0 creates the head of the list, attaches it to  
the window, and broadcasts the pointer to all <font face="sans-serif"> MPI</font> processes.  All <font face="sans-serif"> MPI</font> processes then  
concurrently append <tt>N</tt> new elements to the list.  When an <font face="sans-serif"> MPI</font>  
process attempts to   
attach its element to the tail of the list it may discover that its tail pointer  
is stale and it must chase ahead to the new tail before the element can be  
attached.  
This example requires some modification to  
work in an environment where the layout of the structures is different on  
different <font face="sans-serif"> MPI</font> processes.  
<P> 
<P><img width=758 height=1408 src="img402.gif" alt="Image file"><P>
  
<P> 
<P> 
<P> 
  
  

<P>
<hr>
<a href="node341.htm#Node341"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node306.htm#Node306"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node343.htm#Node343"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node306.htm#Node306"> One-Sided Communications</a>
<b>Next: </b><a href="node343.htm#Node343"> External Interfaces</a>
<b>Previous: </b><a href="node341.htm#Node341"> Registers and Compiler Optimizations</a>
<p>
<HR>
Return to <A HREF="node601.htm">MPI-4.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-4.1 of November 2, 2023<BR>
HTML Generated on November 19, 2023
</FONT>
</body>
</html>
