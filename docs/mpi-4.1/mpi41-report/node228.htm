<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-topol/topol-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi4-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi41-report-html.idx -basedef mpi4defs.txt -o mpi41-report.tex mpi-report.tex 
-->
<title>Topology Inquiry Functions</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node228">9.5.5. Topology Inquiry Functions</span></h2>
<a href="node227.htm#Node227"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node223.htm#Node223"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node229.htm#Node229"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node223.htm#Node223"> Topology Constructors</a>
<b>Next: </b><a href="node229.htm#Node229"> Cartesian Shift Coordinates</a>
<b>Previous: </b><a href="node227.htm#Node227"> Distributed Graph Constructor</a>
<p>
  
<P> 
If a <em> virtual topology</em> has been defined with one of the above functions, then the topology  
information can be looked up using inquiry functions. They all are local  
calls.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TOPO_TEST(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT status</TD><TD>topology type of communicator <font face="sans-serif"> comm</font> (state)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Topo_test(MPI_Comm comm, int *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Topo_test(comm, status, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">status</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TOPO_TEST(COMM, STATUS, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">STATUS</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
The function <font face="sans-serif"> MPI_TOPO_TEST</font> returns the type of topology that  
is associated with a communicator.  
<P> 
The output value <font face="sans-serif"> status</font> is one of the following:  
<P><img width=617 height=102 src="img308.gif" alt="Image file"><P>
<TABLE><TR><TD COLSPAN=2>MPI_GRAPHDIMS_GET(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">nnodes</span>, <span style="white-space:nowrap">nedges</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator with associated graph topology (handle)</TD></TR>  
<TR><TD> OUT nnodes</TD><TD>number of nodes in graph (same as number of <font face="sans-serif"> MPI</font> processes in the group of <font face="sans-serif"> comm</font>) (integer)</TD></TR>  
<TR><TD> OUT nedges</TD><TD>number of edges in graph (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Graphdims_get(MPI_Comm comm, int *nnodes, int *nedges) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Graphdims_get(comm, nnodes, nedges, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">nnodes</span>, <span style="white-space:nowrap">nedges</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GRAPHDIMS_GET(COMM, NNODES, NEDGES, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">NNODES</span>, <span style="white-space:nowrap">NEDGES</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
The functions <font face="sans-serif"> MPI_GRAPHDIMS_GET</font> and  
<font face="sans-serif"> MPI_GRAPH_GET</font> retrieve the graph topology information  
that is associated with the communicator.  
The information provided by <font face="sans-serif"> MPI_GRAPHDIMS_GET</font> can be used  
to dimension the  
vectors <font face="sans-serif"> index</font> and <font face="sans-serif"> edges</font> correctly for the following call  
to <font face="sans-serif"> MPI_GRAPH_GET</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GRAPH_GET(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">maxindex</span>, <span style="white-space:nowrap">maxedges</span>, <span style="white-space:nowrap">index</span>, <span style="white-space:nowrap">edges</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator with associated graph topology (handle)</TD></TR>  
<TR><TD> IN maxindex</TD><TD>length of vector <font face="sans-serif"> index</font> in the calling program (integer)</TD></TR>  
<TR><TD> IN maxedges</TD><TD>length of vector <font face="sans-serif"> edges</font> in the calling program (integer)</TD></TR>  
<TR><TD> OUT index</TD><TD>array of integers containing the graph structure (for details see the definition of <font face="sans-serif"> MPI_GRAPH_CREATE</font>)</TD></TR>  
<TR><TD> OUT edges</TD><TD>array of integers containing the graph structure</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Graph_get(MPI_Comm comm, int maxindex, int maxedges, int index[], int edges[]) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Graph_get(comm, maxindex, maxedges, index, edges, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">maxindex</span>, <span style="white-space:nowrap">maxedges</span> <br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">index(maxindex)</span>, <span style="white-space:nowrap">edges(maxedges)</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GRAPH_GET(COMM, MAXINDEX, MAXEDGES, INDEX, EDGES, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">MAXINDEX</span>, <span style="white-space:nowrap">MAXEDGES</span>, <span style="white-space:nowrap">INDEX(*)</span>, <span style="white-space:nowrap">EDGES(*)</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_CARTDIM_GET(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">ndims</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator with associated Cartesian topology (handle)</TD></TR>  
<TR><TD> OUT ndims</TD><TD>number of dimensions of the Cartesian structure (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Cartdim_get(MPI_Comm comm, int *ndims) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Cartdim_get(comm, ndims, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">ndims</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_CARTDIM_GET(COMM, NDIMS, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">NDIMS</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
The functions <font face="sans-serif"> MPI_CARTDIM_GET</font> and  
<font face="sans-serif"> MPI_CART_GET</font> return the Cartesian topology information that is  
associated with the communicator.  
If <font face="sans-serif"> comm</font> is associated with a zero-dimensional Cartesian topology,  
<font face="sans-serif"> MPI_CARTDIM_GET</font> returns <font face="sans-serif"> ndims</font><font face="sans-serif">  = 0</font> and <font face="sans-serif"> MPI_CART_GET</font> will keep  
all output arguments unchanged.   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_CART_GET(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">maxdims</span>, <span style="white-space:nowrap">dims</span>, <span style="white-space:nowrap">periods</span>, <span style="white-space:nowrap">coords</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator with associated Cartesian topology (handle)</TD></TR>  
<TR><TD> IN maxdims</TD><TD>length of vectors <font face="sans-serif"> dims</font>, <font face="sans-serif"> periods</font>, and <font face="sans-serif"> coords</font> in the calling program (integer)</TD></TR>  
<TR><TD> OUT dims</TD><TD>number of <font face="sans-serif"> MPI</font> processes for each Cartesian dimension (array of integers)</TD></TR>  
<TR><TD> OUT periods</TD><TD>periodicity (<font face="sans-serif"> true</font>/<font face="sans-serif"> false</font>) for each Cartesian dimension (array of logicals)</TD></TR>  
<TR><TD> OUT coords</TD><TD>coordinates of calling <font face="sans-serif"> MPI</font> process in Cartesian structure (array of integers)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Cart_get(MPI_Comm comm, int maxdims, int dims[], int periods[], int coords[]) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Cart_get(comm, maxdims, dims, periods, coords, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">maxdims</span> <br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">dims(maxdims)</span>, <span style="white-space:nowrap">coords(maxdims)</span> <br>LOGICAL, INTENT(OUT) :: <span style="white-space:nowrap">periods(maxdims)</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_CART_GET(COMM, MAXDIMS, DIMS, PERIODS, COORDS, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">MAXDIMS</span>, <span style="white-space:nowrap">DIMS(*)</span>, <span style="white-space:nowrap">COORDS(*)</span>, <span style="white-space:nowrap">IERROR</span> <br>LOGICAL <span style="white-space:nowrap">PERIODS(*)</span> <br></tt>  
If <font face="sans-serif"> maxdims</font> in a call to <font face="sans-serif"> MPI_CART_GET</font> is less than the number of dimensions of the Cartesian topology associated with the communicator <font face="sans-serif"> comm</font>, the outcome is unspecified.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_CART_RANK(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">coords</span>, <span style="white-space:nowrap">rank</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator with associated Cartesian topology (handle)</TD></TR>  
<TR><TD> IN coords</TD><TD>integer array (of size <font face="sans-serif"> ndims</font>) specifying the Cartesian coordinates of an <font face="sans-serif"> MPI</font> process</TD></TR>  
<TR><TD> OUT rank</TD><TD>rank of specified <font face="sans-serif"> MPI</font> process within group of <font face="sans-serif"> comm</font> (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Cart_rank(MPI_Comm comm, const int coords[], int *rank) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Cart_rank(comm, coords, rank, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">coords(*)</span> <br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">rank</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_CART_RANK(COMM, COORDS, RANK, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">COORDS(*)</span>, <span style="white-space:nowrap">RANK</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
For a communicator with an associated Cartesian topology, the function  
<font face="sans-serif"> MPI_CART_RANK</font> translates the logical coordinates of an <font face="sans-serif"> MPI</font> process to  
the corresponding rank in the group of the communicator.  
For dimension <font face="sans-serif"> i</font> with <font face="sans-serif"> periods(i) = true</font>, if the coordinate,  
<font face="sans-serif"> coords(i)</font>, is out of range, that is, <span style="white-space:nowrap"><font face="sans-serif"> coords(i) <i>&lt;</i> 0</font></span> or  
<span style="white-space:nowrap"><font face="sans-serif"> coords(i) <i>&le;</i> dims(i)</font></span>, it is shifted back to the interval  
<span style="white-space:nowrap"><font face="sans-serif"> 0 <i>&ge;</i> coords(i) <i>&lt;</i> dims(i)</font></span> automatically. Out-of-range  
coordinates are erroneous for nonperiodic dimensions.  
 <P> 
If <font face="sans-serif"> comm</font> is associated with a zero-dimensional Cartesian topology,  
<font face="sans-serif"> coords</font> is not significant and 0 is returned in <font face="sans-serif"> rank</font>.   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_CART_COORDS(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">rank</span>, <span style="white-space:nowrap">maxdims</span>, <span style="white-space:nowrap">coords</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator with associated Cartesian topology (handle)</TD></TR>  
<TR><TD> IN rank</TD><TD>rank of an <font face="sans-serif"> MPI</font> process within group of <font face="sans-serif"> comm</font> (integer)</TD></TR>  
<TR><TD> IN maxdims</TD><TD>length of vector  <font face="sans-serif"> coords</font> in the calling program (integer)</TD></TR>  
<TR><TD> OUT coords</TD><TD>coordinates of the <font face="sans-serif"> MPI</font> process with the rank <font face="sans-serif"> rank</font> in Cartesian structure (array of integers)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Cart_coords(MPI_Comm comm, int rank, int maxdims, int coords[]) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Cart_coords(comm, rank, maxdims, coords, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">rank</span>, <span style="white-space:nowrap">maxdims</span> <br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">coords(maxdims)</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_CART_COORDS(COMM, RANK, MAXDIMS, COORDS, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">RANK</span>, <span style="white-space:nowrap">MAXDIMS</span>, <span style="white-space:nowrap">COORDS(*)</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
The inverse mapping, rank-to-coordinates translation is provided by  
<font face="sans-serif"> MPI_CART_COORDS</font>.  
If <font face="sans-serif"> comm</font> is associated with a zero-dimensional Cartesian topology,  
<font face="sans-serif"> coords</font> will be unchanged.   
If <font face="sans-serif"> maxdims</font> is less than the number of dimensions of the Cartesian topology associated with the communicator <font face="sans-serif"> comm</font>, the outcome is unspecified.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GRAPH_NEIGHBORS_COUNT(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">rank</span>, <span style="white-space:nowrap">nneighbors</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator with associated graph topology (handle)</TD></TR>  
<TR><TD> IN rank</TD><TD>rank of <font face="sans-serif"> MPI</font> process in group of <font face="sans-serif"> comm</font> (integer)</TD></TR>  
<TR><TD> OUT nneighbors</TD><TD>number of neighbors of specified <font face="sans-serif"> MPI</font> process (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Graph_neighbors_count(MPI_Comm comm, int rank, int *nneighbors) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Graph_neighbors_count(comm, rank, nneighbors, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">rank</span> <br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">nneighbors</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GRAPH_NEIGHBORS_COUNT(COMM, RANK, NNEIGHBORS, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">RANK</span>, <span style="white-space:nowrap">NNEIGHBORS</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GRAPH_NEIGHBORS(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">rank</span>, <span style="white-space:nowrap">maxneighbors</span>, <span style="white-space:nowrap">neighbors</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator with associated graph topology (handle)</TD></TR>  
<TR><TD> IN rank</TD><TD>rank of <font face="sans-serif"> MPI</font> process in group of <font face="sans-serif"> comm</font> (integer)</TD></TR>  
<TR><TD> IN maxneighbors</TD><TD>size of array <font face="sans-serif"> neighbors</font> (integer)</TD></TR>  
<TR><TD> OUT neighbors</TD><TD>ranks of <font face="sans-serif"> MPI</font> processes that are neighbors to specified <font face="sans-serif"> MPI</font> process (array of integers)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Graph_neighbors(MPI_Comm comm, int rank, int maxneighbors, int neighbors[]) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Graph_neighbors(comm, rank, maxneighbors, neighbors, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">rank</span>, <span style="white-space:nowrap">maxneighbors</span> <br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">neighbors(maxneighbors)</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GRAPH_NEIGHBORS(COMM, RANK, MAXNEIGHBORS, NEIGHBORS, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">RANK</span>, <span style="white-space:nowrap">MAXNEIGHBORS</span>, <span style="white-space:nowrap">NEIGHBORS(*)</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_GRAPH_NEIGHBORS_COUNT</font> and <font face="sans-serif"> MPI_GRAPH_NEIGHBORS</font> provide    
adjacency information for a graph topology.    
The returned count and array of neighbors for the queried rank will   
both include <em> all</em> neighbors and reflect the same edge ordering as   
was specified by the original call to <font face="sans-serif"> MPI_GRAPH_CREATE</font>.   
Specifically, <font face="sans-serif"> MPI_GRAPH_NEIGHBORS_COUNT</font> and   
<font face="sans-serif"> MPI_GRAPH_NEIGHBORS</font> will return values based on the original   
<font face="sans-serif"> index</font> and <font face="sans-serif"> edges</font> array passed to <font face="sans-serif"> MPI_GRAPH_CREATE</font>  
(for the purpose of this example, we assume that <font face="sans-serif"> index[-1]</font> is zero):  
<P> 
<ul> 
 
<li>The number of neighbors (<font face="sans-serif"> nneighbors</font>) returned from  <font face="sans-serif"> MPI_GRAPH_NEIGHBORS_COUNT</font> will be (<font face="sans-serif"> index[rank]</font> -   
  <font face="sans-serif"> index[rank-1]</font>).   
 
<li>The <font face="sans-serif"> neighbors</font> array returned from   
  <font face="sans-serif"> MPI_GRAPH_NEIGHBORS</font> will be <span style="white-space:nowrap"><font face="sans-serif"> edges[index[rank-1]]</font></span>  
  through <span style="white-space:nowrap"><font face="sans-serif"> edges[index[rank]-1]</font></span>.  
</ul> 
<br> 
<br><b> Example</b>  
     
Inquiry of graph topology information.  
<P> 
Assume there are four <font face="sans-serif"> MPI</font> processes with ranks 0, 1, 2, 3 in the input communicator with the following  
  adjacency matrix (note that some neighbors are listed multiple times):  
<P> 
<div style="text-align:center">  
  <TABLE><TR><TD ALIGN="CENTER">     
  <font face="sans-serif"> MPI</font> process</TD><TD ALIGN="LEFT"> neighbors </TD></TR> 
<TR><TD ALIGN="CENTER">  
     
  0</TD><TD ALIGN="LEFT"> 1, 1, 3   </TD></TR> 
<TR><TD ALIGN="CENTER">  
  1</TD><TD ALIGN="LEFT"> 0, 0      </TD></TR> 
<TR><TD ALIGN="CENTER">  
  2</TD><TD ALIGN="LEFT"> 3         </TD></TR> 
<TR><TD ALIGN="CENTER">  
  3</TD><TD ALIGN="LEFT"> 0, 2, 2   </TD></TR> 
<TR><TD ALIGN="CENTER">  
     
  </TD></TR></TABLE> 
</div>  
   <P> 
Thus, the input arguments to <font face="sans-serif"> MPI_GRAPH_CREATE</font> are:  
<div style="text-align:center">  
  <TABLE><TR><TD ALIGN="LEFT">  nnodes =</TD><TD ALIGN="LEFT"> 4 </TD></TR> 
<TR><TD ALIGN="LEFT">  
  index =</TD><TD ALIGN="LEFT"> 3, 5, 6, 9 </TD></TR> 
<TR><TD ALIGN="LEFT">  
  edges =</TD><TD ALIGN="LEFT"> 1, 1, 3, 0, 0, 3, 0, 2, 2   
  </TD></TR></TABLE> 
</div>     
<P> 
 Therefore, calling <font face="sans-serif"> MPI_GRAPH_NEIGHBORS_COUNT</font> and  
  <font face="sans-serif"> MPI_GRAPH_NEIGHBORS</font> for each of the four <font face="sans-serif"> MPI</font> processes will return:  
<P> 
<div style="text-align:center">  
  <TABLE><TR><TD ALIGN="CENTER">  <TD ALIGN="CENTER" COLSPAN=1><b> Input rank</b></TD><TD ALIGN="LEFT"> <TD ALIGN="CENTER" COLSPAN=1><b> Count</b></TD><TD ALIGN="LEFT">   
  <TD ALIGN="CENTER" COLSPAN=1><b> Neighbors</b> </TD></TR> 
<TR><TD ALIGN="CENTER">  
     
  0</TD><TD ALIGN="CENTER"> 3</TD><TD ALIGN="LEFT"> 1, 1, 3 </TD></TR> 
<TR><TD ALIGN="CENTER">  
  1</TD><TD ALIGN="CENTER"> 2</TD><TD ALIGN="LEFT"> 0, 0 </TD></TR> 
<TR><TD ALIGN="CENTER">  
  2</TD><TD ALIGN="CENTER"> 1</TD><TD ALIGN="LEFT"> 3 </TD></TR> 
<TR><TD ALIGN="CENTER">  
  3</TD><TD ALIGN="CENTER"> 3</TD><TD ALIGN="LEFT"> 0, 2, 2 </TD></TR> 
<TR><TD ALIGN="CENTER">  
     
  </TD></TR></TABLE> 
</div>  
   
<P> 
<br><b> Example</b>  
  
Using a communicator with an associated graph topology that represents a shuffle-exchange network.  
<P> 
Suppose that <font face="sans-serif"> comm</font> is a communicator with a  
shuffle-exchange topology.   The group has <i>2<SUP>n</SUP></i> members.  
Each <font face="sans-serif"> MPI</font> process is labeled by <i>a<SUB>1</SUB> , ..., a<SUB>n</SUB></i> with <img width=100 height=23 src="img309.gif" alt="Image file">
, and has three neighbors:  
exchange(<img width=285 height=23 src="img310.gif" alt="Image file">
  
(<img width=91 height=15 src="img311.gif" alt="Image file">
), shuffle(<i>a<SUB>1</SUB> , ..., a<SUB>n</SUB> )= a<SUB>2</SUB> , ..., 
a<SUB>n</SUB>, a<SUB>1</SUB></i>, and unshuffle(<i>a<SUB>1</SUB> , ..., a<SUB>n</SUB> ) = a<SUB>n</SUB> , a<SUB>1</SUB> , ... , a<SUB>n-1</SUB></i>.  
The graph adjacency list is illustrated below for <i>n=3</i>.  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD ALIGN="CENTER">  
<TD ALIGN="CENTER" COLSPAN=2><b> node</b></TD><TD ALIGN="CENTER"><b> exchange</b></TD><TD ALIGN="CENTER"><b> shuffle</b></TD><TD ALIGN="LEFT"><b> unshuffle</b></TD></TR> 
<TR><TD ALIGN="CENTER">  
</TD><TD ALIGN="CENTER"></TD><TD ALIGN="CENTER"> neighbors(1)</TD><TD ALIGN="CENTER"> neighbors(2)</TD><TD ALIGN="CENTER"> neighbors(3) </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
0</TD><TD ALIGN="CENTER"> (000)</TD><TD ALIGN="CENTER"> 1</TD><TD ALIGN="CENTER"> 0</TD><TD ALIGN="CENTER"> 0</TD></TR> 
<TR><TD ALIGN="CENTER">  
1</TD><TD ALIGN="CENTER"> (001)</TD><TD ALIGN="CENTER"> 0</TD><TD ALIGN="CENTER"> 2</TD><TD ALIGN="CENTER"> 4</TD></TR> 
<TR><TD ALIGN="CENTER">  
2</TD><TD ALIGN="CENTER"> (010)</TD><TD ALIGN="CENTER"> 3</TD><TD ALIGN="CENTER"> 4</TD><TD ALIGN="CENTER"> 1</TD></TR> 
<TR><TD ALIGN="CENTER">  
3</TD><TD ALIGN="CENTER"> (011)</TD><TD ALIGN="CENTER"> 2</TD><TD ALIGN="CENTER"> 6</TD><TD ALIGN="CENTER"> 5</TD></TR> 
<TR><TD ALIGN="CENTER">  
4</TD><TD ALIGN="CENTER"> (100)</TD><TD ALIGN="CENTER"> 5</TD><TD ALIGN="CENTER"> 1</TD><TD ALIGN="CENTER"> 2</TD></TR> 
<TR><TD ALIGN="CENTER">  
5</TD><TD ALIGN="CENTER"> (101)</TD><TD ALIGN="CENTER"> 4</TD><TD ALIGN="CENTER"> 3</TD><TD ALIGN="CENTER"> 6</TD></TR> 
<TR><TD ALIGN="CENTER">  
6</TD><TD ALIGN="CENTER"> (110)</TD><TD ALIGN="CENTER"> 7</TD><TD ALIGN="CENTER"> 5</TD><TD ALIGN="CENTER"> 3</TD></TR> 
<TR><TD ALIGN="CENTER">  
7</TD><TD ALIGN="CENTER"> (111)</TD><TD ALIGN="CENTER"> 6</TD><TD ALIGN="CENTER"> 7</TD><TD ALIGN="CENTER"> 7</TD></TR> 
<TR><TD ALIGN="CENTER">  
  
</TD></TR></TABLE> 
</div>  
<P> 
Suppose that the communicator <font face="sans-serif"> comm</font> has this topology associated with it.  
The following code fragment cycles through the three types of neighbors  
and performs an appropriate permutation for each.  
<P> 
<P><img width=769 height=324 src="img312.gif" alt="Image file"><P>
  
<P> 
<font face="sans-serif"> MPI_DIST_GRAPH_NEIGHBORS_COUNT</font> and <font face="sans-serif"> MPI_DIST_GRAPH_NEIGHBORS</font>   
provide adjacency information for a distributed graph topology.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_DIST_GRAPH_NEIGHBORS_COUNT(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">indegree</span>, <span style="white-space:nowrap">outdegree</span>, <span style="white-space:nowrap">weighted</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator with associated distributed graph topology (handle)</TD></TR>  
<TR><TD> OUT indegree</TD><TD>number of edges into this <font face="sans-serif"> MPI</font> process (non-negative integer)</TD></TR>  
<TR><TD> OUT outdegree</TD><TD>number of edges out of this <font face="sans-serif"> MPI</font> process (non-negative integer)</TD></TR>  
<TR><TD> OUT weighted</TD><TD><font face="sans-serif"> false</font> if <font face="sans-serif"> MPI_UNWEIGHTED</font> was supplied during creation, <font face="sans-serif"> true</font> otherwise (logical)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Dist_graph_neighbors_count(MPI_Comm comm, int *indegree, int *outdegree, int *weighted) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Dist_graph_neighbors_count(comm, indegree, outdegree, weighted, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">indegree</span>, <span style="white-space:nowrap">outdegree</span> <br>LOGICAL, INTENT(OUT) :: <span style="white-space:nowrap">weighted</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_DIST_GRAPH_NEIGHBORS_COUNT(COMM, INDEGREE, OUTDEGREE, WEIGHTED, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">INDEGREE</span>, <span style="white-space:nowrap">OUTDEGREE</span>, <span style="white-space:nowrap">IERROR</span> <br>LOGICAL <span style="white-space:nowrap">WEIGHTED</span> <br></tt>  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_DIST_GRAPH_NEIGHBORS(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">maxindegree</span>, <span style="white-space:nowrap">sources</span>, <span style="white-space:nowrap">sourceweights</span>, <span style="white-space:nowrap">maxoutdegree</span>, <span style="white-space:nowrap">destinations</span>, <span style="white-space:nowrap">destweights</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator with associated distributed graph topology (handle)</TD></TR>  
<TR><TD> IN maxindegree</TD><TD>size of sources and sourceweights arrays (non-negative integer)</TD></TR>  
<TR><TD> OUT sources</TD><TD>ranks of <font face="sans-serif"> MPI</font> processes for which the calling <font face="sans-serif"> MPI</font> process is a destination (array of non-negative integers)</TD></TR>  
<TR><TD> OUT sourceweights</TD><TD>weights of the edges into the calling <font face="sans-serif"> MPI</font> process (array of non-negative integers)</TD></TR>  
<TR><TD> IN maxoutdegree</TD><TD>size of destinations and destweights arrays (non-negative integer)</TD></TR>  
<TR><TD> OUT destinations</TD><TD>ranks of <font face="sans-serif"> MPI</font> processes for which the calling <font face="sans-serif"> MPI</font> process is a source (array of non-negative integers)</TD></TR>  
<TR><TD> OUT destweights</TD><TD>weights of the edges out of the calling <font face="sans-serif"> MPI</font> process (array of non-negative integers)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Dist_graph_neighbors(MPI_Comm comm, int maxindegree, int sources[], int sourceweights[], int maxoutdegree, int destinations[], int destweights[]) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Dist_graph_neighbors(comm, maxindegree, sources, sourceweights, maxoutdegree, destinations, destweights, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">maxindegree</span>, <span style="white-space:nowrap">maxoutdegree</span> <br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">sources(maxindegree)</span>, <span style="white-space:nowrap">destinations(maxoutdegree)</span> <br>INTEGER :: <span style="white-space:nowrap">sourceweights(*)</span>, <span style="white-space:nowrap">destweights(*)</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_DIST_GRAPH_NEIGHBORS(COMM, MAXINDEGREE, SOURCES, SOURCEWEIGHTS, MAXOUTDEGREE, DESTINATIONS, DESTWEIGHTS, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">MAXINDEGREE</span>, <span style="white-space:nowrap">SOURCES(*)</span>, <span style="white-space:nowrap">SOURCEWEIGHTS(*)</span>, <span style="white-space:nowrap">MAXOUTDEGREE</span>, <span style="white-space:nowrap">DESTINATIONS(*)</span>, <span style="white-space:nowrap">DESTWEIGHTS(*)</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
These calls are local. The number of edges into and out of the <font face="sans-serif"> MPI</font> process  
returned by <font face="sans-serif"> MPI_DIST_GRAPH_NEIGHBORS_COUNT</font> are the total  
number of such edges given in the call to  
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE_ADJACENT</font> or  
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font> (potentially by <font face="sans-serif"> MPI</font> processes other  
than the calling <font face="sans-serif"> MPI</font> process in the case of  
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font>). Multiply-defined edges are all  
counted and returned by <font face="sans-serif"> MPI_DIST_GRAPH_NEIGHBORS</font> in some  
order. If <font face="sans-serif"> MPI_UNWEIGHTED</font> is supplied for  
<font face="sans-serif"> sourceweights</font> or <font face="sans-serif"> destweights</font> or both, or if  
<font face="sans-serif"> MPI_UNWEIGHTED</font> was supplied during the construction of the  
graph then no weight information is returned in that array or those  
arrays.   
If the communicator was created with <font face="sans-serif"> MPI_DIST_GRAPH_CREATE_ADJACENT</font>  
then for each <font face="sans-serif"> MPI</font> process in <font face="sans-serif"> comm</font>, the order of the values in  
<font face="sans-serif"> sources</font> and <font face="sans-serif"> destinations</font> is identical to the input  
that was used by the <font face="sans-serif"> MPI</font> process with the same rank in <font face="sans-serif"> comm_old</font>  
in the creation call.  
If the communicator was created with <font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font>  
then the   
only requirement on the order of values in  
<font face="sans-serif"> sources</font> and <font face="sans-serif"> destinations</font> is that two calls to the  
routine with same input argument <font face="sans-serif"> comm</font> will return the same  
sequence of edges. If <font face="sans-serif"> maxindegree</font> or <font face="sans-serif"> maxoutdegree</font> is  
smaller than the numbers returned by  
<font face="sans-serif"> MPI_DIST_GRAPH_NEIGHBORS_COUNT</font>, then only the first part  
of the full list is returned.   
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Since the query calls are defined to be local, each <font face="sans-serif"> MPI</font> process needs to  
store the list of its neighbors with incoming and outgoing  
edges. Communication is required at the collective  
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font> call in order to compute the neighbor  
lists for each <font face="sans-serif"> MPI</font> process from the distributed graph specification.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node227.htm#Node227"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node223.htm#Node223"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node229.htm#Node229"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node223.htm#Node223"> Topology Constructors</a>
<b>Next: </b><a href="node229.htm#Node229"> Cartesian Shift Coordinates</a>
<b>Previous: </b><a href="node227.htm#Node227"> Distributed Graph Constructor</a>
<p>
<HR>
Return to <A HREF="node601.htm">MPI-4.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-4.1 of November 2, 2023<BR>
HTML Generated on November 19, 2023
</FONT>
</body>
</html>
