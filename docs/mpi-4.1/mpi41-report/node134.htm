<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-coll/coll-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi4-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi41-report-html.idx -basedef mpi4defs.txt -o mpi41-report.tex mpi-report.tex 
-->
<title>User-Defined Reduction Operations</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node134">7.9.5. User-Defined Reduction Operations</span></h2>
<a href="node133.htm#Node133"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node129.htm#Node129"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node134.htm#Node135"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node129.htm#Node129"> Global Reduction Operations</a>
<b>Next: </b><a href="node134.htm#Node135"> Example of User-Defined Reduce</a>
<b>Previous: </b><a href="node133.htm#Node133"> MINLOC and MAXLOC</a>
<p>
  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_OP_CREATE(<span style="white-space:nowrap">user_fn</span>, <span style="white-space:nowrap">commute</span>, <span style="white-space:nowrap">op</span>)</TD></TR>  
<TR><TD> IN user_fn</TD><TD>user defined function (function)</TD></TR>  
<TR><TD> IN commute</TD><TD><font face="sans-serif"> true</font> if commutative; <font face="sans-serif"> false</font> otherwise.</TD></TR>  
<TR><TD> OUT op</TD><TD>operation (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Op_create(MPI_User_function *user_fn, int commute, MPI_Op *op) <br></tt>  
  
  <tt> int MPI_Op_create_c(MPI_User_function_c *user_fn, int commute, MPI_Op *op) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Op_create(user_fn, commute, op, ierror) <br><br>PROCEDURE(MPI_User_function) :: <span style="white-space:nowrap">user_fn</span> <br>LOGICAL, INTENT(IN) :: <span style="white-space:nowrap">commute</span> <br>TYPE(MPI_Op), INTENT(OUT) :: <span style="white-space:nowrap">op</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Op_create_c(user_fn, commute, op, ierror) !(_c) <br><br>PROCEDURE(MPI_User_function_c) :: <span style="white-space:nowrap">user_fn</span> <br>LOGICAL, INTENT(IN) :: <span style="white-space:nowrap">commute</span> <br>TYPE(MPI_Op), INTENT(OUT) :: <span style="white-space:nowrap">op</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_OP_CREATE(USER_FN, COMMUTE, OP, IERROR) <br><br>EXTERNAL <span style="white-space:nowrap">USER_FN</span> <br>LOGICAL <span style="white-space:nowrap">COMMUTE</span> <br>INTEGER <span style="white-space:nowrap">OP</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_OP_CREATE</font> binds a user-defined reduction operation  
to an <font face="sans-serif"> op</font> handle that can subsequently be used in  
<font face="sans-serif"> MPI_REDUCE</font>, <font face="sans-serif"> MPI_ALLREDUCE</font>,  
<font face="sans-serif"> MPI_REDUCE_SCATTER</font>,  
<font face="sans-serif"> MPI_REDUCE_SCATTER_BLOCK</font>,  
<font face="sans-serif"> MPI_SCAN</font>, <font face="sans-serif"> MPI_EXSCAN</font>, all nonblocking and persistent variants of  
those (see Section <a href="node145.htm#Node145">Nonblocking Collective Operations</a> and Section <a href="node159.htm#Node159">Persistent Collective Operations</a>), and <font face="sans-serif"> MPI_REDUCE_LOCAL</font>.  
The user-defined operation is assumed to be associative.  
If <font face="sans-serif"> commute</font> <i>=</i> <font face="sans-serif"> true</font>, then the operation should be both  
commutative and associative. If  <font face="sans-serif"> commute</font> <i>=</i> <font face="sans-serif"> false</font>,  
then the order of operands is fixed and is defined to be in ascending, process  
rank order, beginning with <font face="sans-serif"> MPI</font> process with rank <font face="sans-serif"> 0</font> in the communicator <font face="sans-serif"> comm</font>.  The order of evaluation can be  
changed, talking advantage of the associativity of the operation.  If  
<font face="sans-serif"> commute</font> <i>=</i> <font face="sans-serif"> true</font> then the order of evaluation can be changed,  
taking advantage of commutativity and associativity.  
<P> 
In Fortran when using <tt>USE mpi_f08</tt>, the large count variant shall  
be called explicitly as <font face="sans-serif"> MPI_Op_create_c</font> (i.e., with suffix ``<tt>_c</tt>'')  
because interface polymorphism cannot be used to differentiate between the  
two different user callback prototypes despite their different type  
signatures.  
<P> 
The argument <font face="sans-serif"> user_fn</font> is the user-defined function, which must have the  
following four arguments: <font face="sans-serif"> invec</font>, <font face="sans-serif"> inoutvec</font>, <font face="sans-serif"> len</font>, and  
<font face="sans-serif"> datatype</font>.  
<P> 
<font face="sans-serif"> MPI_USER_FUNCTION</font> also supports large count types in  
separate additional <font face="sans-serif"> MPI</font> callback function prototype declarations in C (suffixed with the ``<tt>_c</tt>'') and  
in Fortran when using <tt>USE mpi_f08</tt>.  
<P> 
The ISO C prototypes for the functions are the following.  
<P> 
 <tt> typedef void MPI_User_function(void *invec, void *inoutvec, int *len, MPI_Datatype *datatype); <br></tt>  
 <tt> typedef void MPI_User_function_c(void *invec, void *inoutvec, MPI_Count *len, MPI_Datatype *datatype); <br></tt>  
<P> 
The Fortran declarations of the user-defined function <font face="sans-serif"> user_fn</font> appear   
below.  
<P> 
<tt> ABSTRACT INTERFACE<br>&nbsp;&nbsp;&nbsp; <tt> SUBROUTINE MPI_User_function(invec, inoutvec, len, datatype) <br><br>USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR <br>TYPE(C_PTR), VALUE :: <span style="white-space:nowrap">invec</span>, <span style="white-space:nowrap">inoutvec</span> <br>INTEGER :: <span style="white-space:nowrap">len</span> <br>TYPE(MPI_Datatype) :: <span style="white-space:nowrap">datatype</span> <br></tt></tt>  
<tt> ABSTRACT INTERFACE<br>&nbsp;&nbsp;&nbsp; <tt> SUBROUTINE MPI_User_function_c(invec, inoutvec, len, datatype) !(_c) <br><br>USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR <br>TYPE(C_PTR), VALUE :: <span style="white-space:nowrap">invec</span>, <span style="white-space:nowrap">inoutvec</span> <br>INTEGER(KIND=MPI_COUNT_KIND) :: <span style="white-space:nowrap">len</span> <br>TYPE(MPI_Datatype) :: <span style="white-space:nowrap">datatype</span> <br></tt></tt>  
 <tt> SUBROUTINE USER_FUNCTION(INVEC, INOUTVEC, LEN, DATATYPE) <br><br>&lt;type&gt; <span style="white-space:nowrap">INVEC(LEN)</span>, <span style="white-space:nowrap">INOUTVEC(LEN)</span> <br>INTEGER <span style="white-space:nowrap">LEN</span>, <span style="white-space:nowrap">DATATYPE</span> <br></tt>  
<P> 
The <font face="sans-serif"> datatype</font> argument  
is a handle to the datatype that was passed into the call  
to <font face="sans-serif"> MPI_REDUCE</font>.  
The user reduce function should be written such that the following  
holds:  
Let <font face="sans-serif"> u[0], <i>...</i>, u[len-1]</font> be the <font face="sans-serif"> len</font> elements in the  
communication buffer described by the arguments <font face="sans-serif"> invec, len</font>  
and <font face="sans-serif"> datatype</font> when the function is invoked;  
let <font face="sans-serif"> v[0], <i>...</i> , v[len-1]</font> be <font face="sans-serif"> len</font> elements in the  
communication buffer described by the arguments <font face="sans-serif"> inoutvec, len</font>  
and <font face="sans-serif"> datatype</font> when the function is invoked;  
let <font face="sans-serif"> w[0], <i>...</i> , w[len-1]</font> be  <font face="sans-serif"> len</font> elements in the  
communication buffer described by the arguments <font face="sans-serif"> inoutvec, len</font>  
and <font face="sans-serif"> datatype</font> when the function returns;  
then <font face="sans-serif"> w[i] = u[i]<i>&#176;</i>v[i]</font>, for <font face="sans-serif"> i=0 , <i>...</i> , len-1</font>,  
where <i>&#176;</i> is the reduce operation that the function computes.  
<P> 
Informally, we can think of  
<font face="sans-serif"> invec</font> and <font face="sans-serif"> inoutvec</font> as arrays of <font face="sans-serif"> len</font> elements that  
<font face="sans-serif"> user_fn</font>  
is combining.  The result of the reduction over-writes values in  
<font face="sans-serif"> inoutvec</font>, hence the name.  Each invocation of the function results in  
the pointwise evaluation of the reduce operator on <font face="sans-serif"> len</font>  
elements:  
i.e., the function returns in <font face="sans-serif"> inoutvec[i]</font> the value  
<img width=181 height=23 src="img232.gif" alt="Image file">
, for <img width=161 height=18 src="img233.gif" alt="Image file">
,  
where <i>&#176;</i> is the combining operation computed by the function.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The   
<font face="sans-serif"> len</font>   
argument allows  
<font face="sans-serif"> MPI_REDUCE</font> to avoid calling the function for each element  
in the input buffer.  Rather, the system can choose to apply  
the function to chunks of input.  In C, it is passed in as  
a reference for reasons of compatibility with Fortran.  
<P> 
By internally comparing the value of the <font face="sans-serif"> datatype</font> argument to  
known, global handles,  
it is possible to overload the use of a single user-defined function  
for several, different datatypes.  
 (<em> End of rationale.</em>) <br> 
When calling any reduction or prefix scan <font face="sans-serif"> MPI</font> procedure with a  
user-defined <font face="sans-serif"> MPI</font> operator, the type of the <font face="sans-serif"> count</font> parameter in  
the call to the reduction or prefix scan <font face="sans-serif"> MPI</font> procedure does not need  
to be identical to the type of the <font face="sans-serif"> len</font> parameter in the user  
function associated with the user-defined <font face="sans-serif"> MPI</font> operator.  If the  
<font face="sans-serif"> count</font> parameter has a type of <tt> int</tt> in C or  
<tt> INTEGER</tt> in Fortran and the <font face="sans-serif"> len</font> parameter has a type  
of <font face="sans-serif"> MPI_COUNT</font>, then <font face="sans-serif"> MPI</font> will perform the appropriate widening  
type conversion of the <font face="sans-serif"> len</font> parameter.  If the <font face="sans-serif"> count</font>  
parameter has a type of <font face="sans-serif"> MPI_COUNT</font> and the <font face="sans-serif"> len</font>  
parameter has a type of <tt> int</tt> in C or <tt> INTEGER</tt> in  
Fortran, then <font face="sans-serif"> MPI</font> will perform the appropriate narrowing type  
conversion of the <font face="sans-serif"> len</font> parameter.  If this narrowing  
conversion would result in truncation of the <font face="sans-serif"> len</font> value, then  
<font face="sans-serif"> MPI</font> will call the user function multiple times with a sequence of  
values for <font face="sans-serif"> len</font> that sum to the value of <font face="sans-serif"> count</font>.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
If the number of data items cannot be represented in <font face="sans-serif"> len</font>,  
  the implementation may need to invoke <font face="sans-serif"> user_fn</font> multiple  
  times.  
 (<em> End of advice to implementors.</em>) <br> 
General datatypes may be passed to the user function.  
However, use of datatypes that are not contiguous is likely to lead to  
inefficiencies.  
<P> 
No <font face="sans-serif"> MPI</font> communication function may be called inside the user function.  
<font face="sans-serif"> MPI_ABORT</font> may be called inside the  
function in case of an error.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Suppose one defines a library of user-defined reduce  
functions that are overloaded: the <font face="sans-serif"> datatype</font> argument is used  
to select the right execution path at each invocation, according to  
the types of the operands.  
The user-defined reduce function cannot ``decode'' the  
<font face="sans-serif"> datatype</font> argument that it is passed, and cannot identify,  
by itself, the correspondence between the datatype handles and the datatype  
they represent.  This correspondence was established when the datatypes  
were created.  Before the library is used, a library initialization  
preamble must be executed.  This preamble code will define the  
datatypes that are used by the library, and store handles to these  
datatypes in global, static variables that are shared by the user code and the  
library code.  
<P> 
The Fortran version of <font face="sans-serif"> MPI_REDUCE</font> will invoke a user-defined reduce  
function using the Fortran calling conventions and will pass a Fortran-type  
datatype argument;  the C version will use C calling convention and the C  
representation of a datatype handle.  Users who plan to mix languages should  
define their reduction functions accordingly.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
We outline below a naive and inefficient implementation of <font face="sans-serif"> MPI_REDUCE</font>  
not   
supporting the ``in place'' option and only valid for intra-communicators.  
<P> 
<P><img width=779 height=524 src="img234.gif" alt="Image file"><P>
The reduction computation proceeds, sequentially, from <font face="sans-serif"> MPI</font> process with rank <tt>0</tt>  
to <font face="sans-serif"> MPI</font> process with rank  
<tt>groupsize-1</tt>.    
This order is chosen so as to respect  
the order of a possibly noncommutative operator defined by the  
function <tt>User_reduce()</tt>.  
A more efficient implementation is achieved by taking advantage  
of associativity and  
using a logarithmic tree reduction.  Commutativity can be used  
to advantage, for those cases in which the <font face="sans-serif"> commute</font> argument  
to <font face="sans-serif"> MPI_OP_CREATE</font> is true.  Also, the amount of temporary buffer  
space required can be reduced, and communication can be pipelined with  
computation, by transferring and reducing the elements in chunks of  
size <tt>len</tt> <i>&lt;</i><tt>count</tt>.  
<P> 
The predefined reduce operations can be implemented as a library of  
user-defined operations.  However, better performance might be  
achieved if <font face="sans-serif"> MPI_REDUCE</font> handles these functions as a special  
case.  
 (<em> End of advice to implementors.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_OP_FREE(<span style="white-space:nowrap">op</span>)</TD></TR>  
<TR><TD> INOUT op</TD><TD>operation (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Op_free(MPI_Op *op) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Op_free(op, ierror) <br><br>TYPE(MPI_Op), INTENT(INOUT) :: <span style="white-space:nowrap">op</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_OP_FREE(OP, IERROR) <br><br>INTEGER <span style="white-space:nowrap">OP</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Marks a user-defined reduction operation for deallocation and sets  
<font face="sans-serif"> op</font> to <font face="sans-serif"> MPI_OP_NULL</font>.  
<P> 
<ul> 
</ul> 

<P>
<hr>
<a href="node133.htm#Node133"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node129.htm#Node129"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node134.htm#Node135"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node129.htm#Node129"> Global Reduction Operations</a>
<b>Next: </b><a href="node134.htm#Node135"> Example of User-Defined Reduce</a>
<b>Previous: </b><a href="node133.htm#Node133"> MINLOC and MAXLOC</a>
<p>
<hr><h3><span id="Node135">7.9.5.1. Example of User-Defined Reduce</span></h3>
<a href="node134.htm#Node134"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node134.htm#Node134"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node136.htm#Node136"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node134.htm#Node134"> User-Defined Reduction Operations</a>
<b>Next: </b><a href="node136.htm#Node136"> All-Reduce</a>
<b>Previous: </b><a href="node134.htm#Node134"> User-Defined Reduction Operations</a>
<p>
  
<P> 
The example in this section uses an intra-communicator.  
<P> 
<br><b> Example</b>  
  
Compute the product of an array of complex numbers, in C.  
<P><img width=819 height=1121 src="img235.gif" alt="Image file"><P>
  
 <P> 
<br><b> Example</b>  
  
How to use the <tt>mpi_f08</tt> interface of the Fortran <tt>MPI_User_function</tt>.  
<P><img width=819 height=324 src="img236.gif" alt="Image file"><P>
  
<P> 

<P>
<hr>
<a href="node134.htm#Node134"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node134.htm#Node134"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node136.htm#Node136"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node134.htm#Node134"> User-Defined Reduction Operations</a>
<b>Next: </b><a href="node136.htm#Node136"> All-Reduce</a>
<b>Previous: </b><a href="node134.htm#Node134"> User-Defined Reduction Operations</a>
<p>
<HR>
Return to <A HREF="node601.htm">MPI-4.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-4.1 of November 2, 2023<BR>
HTML Generated on November 19, 2023
</FONT>
</body>
</html>
