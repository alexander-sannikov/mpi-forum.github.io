<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-datatypes/datatypes-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi4-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi41-report-html.idx -basedef mpi4defs.txt -o mpi41-report.tex mpi-report.tex 
-->
<title>Datatype Constructors</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node98">6.1.2. Datatype Constructors</span></h2>
<a href="node97.htm#Node97"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node96.htm#Node96"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node99.htm#Node99"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node96.htm#Node96"> Derived Datatypes</a>
<b>Next: </b><a href="node99.htm#Node99"> Subarray Datatype Constructor</a>
<b>Previous: </b><a href="node97.htm#Node97"> Type Constructors with Explicit Addresses</a>
<p>
  
<P> 
<b> Contiguous.</b>  
The simplest datatype constructor is  
<font face="sans-serif"> MPI_TYPE_CONTIGUOUS</font>, which  
allows replication of a datatype into contiguous locations.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CONTIGUOUS(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD> IN count</TD><TD>replication count (non-negative integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_contiguous(int count, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_contiguous_c(MPI_Count count, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_contiguous(count, oldtype, newtype, ierror) <br><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_contiguous(count, oldtype, newtype, ierror) !(_c) <br><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CONTIGUOUS(COUNT, OLDTYPE, NEWTYPE, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
  
<font face="sans-serif"> newtype</font> is the datatype obtained by concatenating  
<font face="sans-serif"> count</font> copies of  
<font face="sans-serif"> oldtype</font>.  
Concatenation is defined using <em> extent</em> as the size of  
the concatenated copies.  
<P> 
<br><b> Example</b>  
  
Let <font face="sans-serif"> oldtype</font> have type map  
<img width=228 height=23 src="img53.gif" alt="Image file">
  
with extent 16,  
and let <img width=92 height=15 src="img54.gif" alt="Image file">
.  The type map of  
the datatype returned by <font face="sans-serif"> newtype</font> is  
<img width=696 height=23 src="img55.gif" alt="Image file">
  
i.e., alternating <tt> double</tt> and <tt> char</tt> elements, with displacements  
<i>0, 8, 16, 24, 32, 40</i>.  
  
<P> 
In general,  
assume that the type map of <font face="sans-serif"> oldtype</font> is  
<img width=378 height=23 src="img56.gif" alt="Image file">
  
with extent <i>ex</i>.  
Then <font face="sans-serif"> newtype</font> has a type map with <img width=78 height=13 src="img57.gif" alt="Image file">
  
entries defined by:  
<img width=832 height=23 src="img58.gif" alt="Image file">
  
<img width=762 height=23 src="img59.gif" alt="Image file">
  
<P> 
<b> Vector.</b>  
The procedure  
<font face="sans-serif"> MPI_TYPE_VECTOR</font> is a more general constructor that  
allows replication of a datatype  
into locations that consist of equally spaced blocks.  Each block  
is obtained by concatenating the same number of copies of the old datatype.  
The spacing between blocks is a multiple of the extent of the old datatype.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_VECTOR(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">stride</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks (non-negative integer)</TD></TR>  
<TR><TD> IN blocklength</TD><TD>number of elements in each block (non-negative integer)</TD></TR>  
<TR><TD> IN stride</TD><TD>number of elements between start of each block (integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_vector(int count, int blocklength, int stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_vector_c(MPI_Count count, MPI_Count blocklength, MPI_Count stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_vector(count, blocklength, stride, oldtype, newtype, ierror) <br><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">stride</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_vector(count, blocklength, stride, oldtype, newtype, ierror) !(_c) <br><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">stride</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_VECTOR(COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">BLOCKLENGTH</span>, <span style="white-space:nowrap">STRIDE</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<br><b> Example</b>  
  
Assume, again, that <font face="sans-serif"> oldtype</font> has type map  
<img width=228 height=23 src="img60.gif" alt="Image file">
  
with extent 16.  
A call to <font face="sans-serif"> MPI_TYPE_VECTOR(2, 3, 4, oldtype, newtype)</font> will  
create the datatype with type map,  
<img width=686 height=23 src="img61.gif" alt="Image file">
  
<img width=719 height=23 src="img62.gif" alt="Image file">
  
That is, two blocks with three copies each of the old  
type, with a stride of 4 elements (<i>4 &#183; 16</i> bytes) between the the start of each block.  
  
<P> 
<br><b> Example</b>  
  
A call to <font face="sans-serif"> MPI_TYPE_VECTOR(3, 1, -2, oldtype, newtype)</font> will create  
the datatype,  
<img width=767 height=23 src="img63.gif" alt="Image file">
  
  
<P> 
In general, assume that <font face="sans-serif"> oldtype</font> has type map,  
<img width=378 height=23 src="img64.gif" alt="Image file">
  
with extent <i>ex</i>.  Let <font face="sans-serif"> bl</font> be the <font face="sans-serif"> blocklength</font>.  
The newly created  datatype has a type map with  
<img width=112 height=16 src="img65.gif" alt="Image file">
<P> 
entries:  
<img width=367 height=23 src="img66.gif" alt="Image file">
  
<img width=498 height=23 src="img67.gif" alt="Image file">
  
<img width=639 height=23 src="img68.gif" alt="Image file">
  
<img width=635 height=23 src="img69.gif" alt="Image file">
  
<img width=839 height=23 src="img70.gif" alt="Image file">
  
<img width=416 height=23 src="img71.gif" alt="Image file">
  
<img width=465 height=23 src="img72.gif" alt="Image file">
  
<img width=518 height=23 src="img73.gif" alt="Image file">
  
<img width=537 height=23 src="img74.gif" alt="Image file">
  
<P> 
A call to <font face="sans-serif"> MPI_TYPE_CONTIGUOUS(count, oldtype, newtype)</font> is  
equivalent to a call to  
<font face="sans-serif"> MPI_TYPE_VECTOR(count, 1, 1, oldtype, newtype)</font>, or to a call to  
<font face="sans-serif"> MPI_TYPE_VECTOR(1, count, n, oldtype, newtype)</font>, where <font face="sans-serif"> n</font>  
is an arbitrary integer value.  
<P> 
<b> Hvector.</b>  
The procedure  
<font face="sans-serif"> MPI_TYPE_CREATE_HVECTOR</font>  
is identical to  
<font face="sans-serif"> MPI_TYPE_VECTOR</font>, except that <font face="sans-serif"> stride</font> is given in bytes,  
rather than in elements.  The use for both types of vector  
constructors is illustrated in Section <a href="node110.htm#Node110">Examples</a>.  
(<font face="sans-serif"> H</font> stands for ``heterogeneous'').  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_HVECTOR(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">stride</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks (non-negative integer)</TD></TR>  
<TR><TD> IN blocklength</TD><TD>number of elements in each block (non-negative integer)</TD></TR>  
<TR><TD> IN stride</TD><TD>number of bytes between start of each block (integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_create_hvector(int count, int blocklength, MPI_Aint stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_create_hvector_c(MPI_Count count, MPI_Count blocklength, MPI_Count stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_create_hvector(count, blocklength, stride, oldtype, newtype, ierror) <br><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span> <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">stride</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_create_hvector(count, blocklength, stride, oldtype, newtype, ierror) !(_c) <br><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">stride</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CREATE_HVECTOR(COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">BLOCKLENGTH</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">STRIDE</span> <br></tt>  
<P> 
Assume that <font face="sans-serif"> oldtype</font> has type map,  
<img width=378 height=23 src="img75.gif" alt="Image file">
  
with extent <i>ex</i>.  Let <font face="sans-serif"> bl</font> be the <font face="sans-serif"> blocklength</font>.  
The newly created  datatype has a type map with  
<img width=115 height=16 src="img76.gif" alt="Image file">
<P> 
entries:  
<img width=367 height=23 src="img77.gif" alt="Image file">
  
<img width=498 height=23 src="img78.gif" alt="Image file">
  
<img width=639 height=23 src="img79.gif" alt="Image file">
  
<img width=555 height=23 src="img80.gif" alt="Image file">
  
<img width=391 height=23 src="img81.gif" alt="Image file">
  
<img width=440 height=23 src="img82.gif" alt="Image file">
  
<img width=808 height=23 src="img83.gif" alt="Image file">
  
<img width=518 height=23 src="img84.gif" alt="Image file">
  
<img width=537 height=23 src="img85.gif" alt="Image file">
  
<P> 
<b> Indexed.</b>  
The procedure  
<font face="sans-serif"> MPI_TYPE_INDEXED</font> allows  
replication of an old datatype into a sequence of blocks (each block is  
a concatenation of the old datatype), where  
each block can contain a different number of copies and have a different  
displacement.  All block displacements are multiples of the old type  
extent.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_INDEXED(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths</span>, <span style="white-space:nowrap">array_of_displacements</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks---also number of entries in <font face="sans-serif"> array_of_displacements</font> and <font face="sans-serif"> array_of_blocklengths</font> (non-negative integer)</TD></TR>  
<TR><TD> IN array_of_blocklengths</TD><TD>number of elements per block (array of non-negative integers)</TD></TR>  
<TR><TD> IN array_of_displacements</TD><TD>displacement for each block, in multiples of <font face="sans-serif"> oldtype</font> (array of integers)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_indexed(int count, const int array_of_blocklengths[], const int array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_indexed_c(MPI_Count count, const MPI_Count array_of_blocklengths[], const MPI_Count array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_indexed(count, array_of_blocklengths, array_of_displacements, oldtype, newtype, ierror) <br><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths(count)</span>, <span style="white-space:nowrap">array_of_displacements(count)</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_indexed(count, array_of_blocklengths, array_of_displacements, oldtype, newtype, ierror) !(_c) <br><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths(count)</span>, <span style="white-space:nowrap">array_of_displacements(count)</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_INDEXED(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">ARRAY_OF_BLOCKLENGTHS(*)</span>, <span style="white-space:nowrap">ARRAY_OF_DISPLACEMENTS(*)</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<br><b> Example</b>  
  
Let <font face="sans-serif"> oldtype</font> have type map  
<img width=228 height=23 src="img86.gif" alt="Image file">
  
with extent 16.  
Let  <font face="sans-serif"> B = (3, 1)</font> and let <font face="sans-serif"> D = (4, 0)</font>.  A call to  
<font face="sans-serif"> MPI_TYPE_INDEXED(2, B, D, oldtype, newtype)</font> returns a datatype with  
type map,  
<img width=720 height=23 src="img87.gif" alt="Image file">
  
<img width=215 height=23 src="img88.gif" alt="Image file">
  
That is, three copies of the old type starting at displacement  
64, and one copy starting at displacement 0.  
  
<P> 
In general,  
assume that <font face="sans-serif"> oldtype</font> has type map,  
<img width=378 height=23 src="img89.gif" alt="Image file">
  
with extent <em> ex</em>.  
Let <font face="sans-serif"> B</font> be the <font face="sans-serif"> array_of_blocklengths</font> argument and  
<font face="sans-serif"> D</font> be the  
<font face="sans-serif"> array_of_displacements</font> argument. The newly created datatype  
has <img width=151 height=27 src="img90.gif" alt="Image file">
 entries:  
<img width=624 height=23 src="img91.gif" alt="Image file">
  
<img width=403 height=23 src="img92.gif" alt="Image file">
  
<img width=452 height=23 src="img93.gif" alt="Image file">
  
<img width=735 height=23 src="img94.gif" alt="Image file">
  
<img width=524 height=23 src="img95.gif" alt="Image file">
  
<img width=543 height=23 src="img96.gif" alt="Image file">
  
<P> 
A call to <font face="sans-serif"> MPI_TYPE_VECTOR(count, blocklength, stride, oldtype,  
newtype)</font> is equivalent to a call to  
<font face="sans-serif"> MPI_TYPE_INDEXED(count, B, D, oldtype, newtype)</font> where  
<img width=361 height=23 src="img97.gif" alt="Image file">
  
and  
<img width=388 height=23 src="img98.gif" alt="Image file">
  
<P> 
<b> Hindexed.</b>  
The procedure  
<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED</font>  
is identical to  
<font face="sans-serif"> MPI_TYPE_INDEXED</font>, except that block displacements in  
<font face="sans-serif"> array_of_displacements</font> are specified in  
bytes, rather than in multiples of the <font face="sans-serif"> oldtype</font> extent.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_HINDEXED(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths</span>, <span style="white-space:nowrap">array_of_displacements</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks---also number of entries in <font face="sans-serif"> array_of_displacements</font> and <font face="sans-serif"> array_of_blocklengths</font> (non-negative integer)</TD></TR>  
<TR><TD> IN array_of_blocklengths</TD><TD>number of elements in each block (array of non-negative integers)</TD></TR>  
<TR><TD> IN array_of_displacements</TD><TD>byte displacement of each block (array of integers)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_create_hindexed(int count, const int array_of_blocklengths[], const MPI_Aint array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_create_hindexed_c(MPI_Count count, const MPI_Count array_of_blocklengths[], const MPI_Count array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_create_hindexed(count, array_of_blocklengths, array_of_displacements, oldtype, newtype, ierror) <br><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths(count)</span> <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">array_of_displacements(count)</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_create_hindexed(count, array_of_blocklengths, array_of_displacements, oldtype, newtype, ierror) !(_c) <br><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths(count)</span>, <span style="white-space:nowrap">array_of_displacements(count)</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CREATE_HINDEXED(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">ARRAY_OF_BLOCKLENGTHS(*)</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">ARRAY_OF_DISPLACEMENTS(*)</span> <br></tt>  
<P> 
Assume that <font face="sans-serif"> oldtype</font> has type map,  
<img width=378 height=23 src="img99.gif" alt="Image file">
  
with extent <i>ex</i>.  
Let <font face="sans-serif"> B</font> be the <font face="sans-serif"> array_of_blocklengths</font> argument and  
<font face="sans-serif"> D</font> be the  
<font face="sans-serif"> array_of_displacements</font> argument. The newly created datatype  
has a type map with  
<img width=151 height=27 src="img100.gif" alt="Image file">
 entries:  
<img width=544 height=23 src="img101.gif" alt="Image file">
  
<img width=403 height=23 src="img102.gif" alt="Image file">
  
<img width=452 height=23 src="img103.gif" alt="Image file">
  
<img width=655 height=23 src="img104.gif" alt="Image file">
  
<img width=524 height=23 src="img105.gif" alt="Image file">
  
<img width=543 height=23 src="img106.gif" alt="Image file">
  
<P> 
<b> Indexed_block.</b>  
This procedure is the same as <font face="sans-serif"> MPI_TYPE_INDEXED</font> except that the  
blocklength is the same for all blocks.  
There are many codes using indirect addressing arising from  
unstructured grids where the blocksize is always 1 (gather/scatter).  The  
following convenience procedure allows for constant blocksize and arbitrary  
displacements.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_INDEXED_BLOCK(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">array_of_displacements</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks---also number of entries in <font face="sans-serif"> array_of_displacements</font> (non-negative integer)</TD></TR>  
<TR><TD> IN blocklength</TD><TD>number of elements in each block (non-negative integer)</TD></TR>  
<TR><TD> IN array_of_displacements</TD><TD>array of displacements, in multiples of <font face="sans-serif"> oldtype</font> (array of integers)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_create_indexed_block(int count, int blocklength, const int array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_create_indexed_block_c(MPI_Count count, MPI_Count blocklength, const MPI_Count array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_create_indexed_block(count, blocklength, array_of_displacements, oldtype, newtype, ierror) <br><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">array_of_displacements(count)</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_create_indexed_block(count, blocklength, array_of_displacements, oldtype, newtype, ierror) !(_c) <br><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">array_of_displacements(count)</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CREATE_INDEXED_BLOCK(COUNT, BLOCKLENGTH, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">BLOCKLENGTH</span>, <span style="white-space:nowrap">ARRAY_OF_DISPLACEMENTS(*)</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<b> Hindexed_block.</b>  
The procedure <font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED_BLOCK</font> is identical  
to <font face="sans-serif"> MPI_TYPE_CREATE_INDEXED_BLOCK</font>, except that block  
displacements in <font face="sans-serif"> array_of_displacements</font> are specified in  
bytes, rather than in multiples of the <font face="sans-serif"> oldtype</font> extent.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_HINDEXED_BLOCK(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">array_of_displacements</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks---also number of entries in <font face="sans-serif"> array_of_displacements</font> (non-negative integer)</TD></TR>  
<TR><TD> IN blocklength</TD><TD>number of elements in each block (non-negative integer)</TD></TR>  
<TR><TD> IN array_of_displacements</TD><TD>byte displacement of each block (array of integers)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_create_hindexed_block(int count, int blocklength, const MPI_Aint array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_create_hindexed_block_c(MPI_Count count, MPI_Count blocklength, const MPI_Count array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_create_hindexed_block(count, blocklength, array_of_displacements, oldtype, newtype, ierror) <br><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span> <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">array_of_displacements(count)</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_create_hindexed_block(count, blocklength, array_of_displacements, oldtype, newtype, ierror) !(_c) <br><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">array_of_displacements(count)</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CREATE_HINDEXED_BLOCK(COUNT, BLOCKLENGTH, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">BLOCKLENGTH</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">ARRAY_OF_DISPLACEMENTS(*)</span> <br></tt>  
<P> 
<b> Struct.</b>  
<font face="sans-serif"> MPI_TYPE_CREATE_STRUCT</font> is the most general type constructor.  
It further generalizes  
<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED</font>  
in that it allows each block to consist of replications of  
different datatypes.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_STRUCT(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths</span>, <span style="white-space:nowrap">array_of_displacements</span>, <span style="white-space:nowrap">array_of_types</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks---also number of entries in arrays <font face="sans-serif"> array_of_types</font>, <font face="sans-serif"> array_of_displacements</font>, and <font face="sans-serif"> array_of_blocklengths</font> (non-negative integer)</TD></TR>  
<TR><TD> IN array_of_blocklengths</TD><TD>number of elements in each block (array of non-negative integers)</TD></TR>  
<TR><TD> IN array_of_displacements</TD><TD>byte displacement of each block (array of integers)</TD></TR>  
<TR><TD> IN array_of_types</TD><TD>type of elements in each block (array of handles)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_create_struct(int count, const int array_of_blocklengths[], const MPI_Aint array_of_displacements[], const MPI_Datatype array_of_types[], MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_create_struct_c(MPI_Count count, const MPI_Count array_of_blocklengths[], const MPI_Count array_of_displacements[], const MPI_Datatype array_of_types[], MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_create_struct(count, array_of_blocklengths, array_of_displacements, array_of_types, newtype, ierror) <br><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths(count)</span> <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">array_of_displacements(count)</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">array_of_types(count)</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_create_struct(count, array_of_blocklengths, array_of_displacements, array_of_types, newtype, ierror) !(_c) <br><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths(count)</span>, <span style="white-space:nowrap">array_of_displacements(count)</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">array_of_types(count)</span> <br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CREATE_STRUCT(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, ARRAY_OF_TYPES, NEWTYPE, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">ARRAY_OF_BLOCKLENGTHS(*)</span>, <span style="white-space:nowrap">ARRAY_OF_TYPES(*)</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">ARRAY_OF_DISPLACEMENTS(*)</span> <br></tt>  
<P> 
<br><b> Example</b>  
  
Let <font face="sans-serif"> type1</font> have type map,  
<P><img width=228 height=23 src="img107.gif" alt="Image file"><P>
  
with extent 16.  
Let <font face="sans-serif"> B = (2, 1, 3)</font>, <font face="sans-serif"> D = (0, 16, 26)</font>,  
and <font face="sans-serif"> T = (MPI_FLOAT, type1, MPI_CHAR)</font>.  Then a call to  
<font face="sans-serif"> MPI_TYPE_CREATE_STRUCT(3, B, D, T, newtype)</font> returns  
a datatype with type map,  
<img width=780 height=23 src="img108.gif" alt="Image file">
  
That is, two copies of <font face="sans-serif"> MPI_FLOAT</font> starting at 0, followed by  
one copy of <font face="sans-serif"> type1</font> starting at 16, followed by three copies of  
<font face="sans-serif"> MPI_CHAR</font>, starting at 26.  
In this example, we assume that a float occupies four bytes.  
  
<P> 
In general,  
let <font face="sans-serif"> T</font> be the <font face="sans-serif"> array_of_types</font> argument, where <font face="sans-serif"> T[i]</font>  
is a handle to,  
<img width=510 height=29 src="img109.gif" alt="Image file">
  
with extent <i>ex<SUB>i</SUB></i>.  
Let  
<font face="sans-serif"> B</font> be the <font face="sans-serif"> array_of_blocklength</font> argument and <font face="sans-serif"> D</font> be  
the <font face="sans-serif"> array_of_displacements</font> argument.Let <font face="sans-serif"> c</font> be the  
<font face="sans-serif"> count</font> argument.  
Then the newly created datatype has a type map with  
<img width=125 height=27 src="img110.gif" alt="Image file">
<P> 
entries:  
<img width=517 height=28 src="img111.gif" alt="Image file">
  
<img width=833 height=28 src="img112.gif" alt="Image file">
  
<img width=669 height=29 src="img113.gif" alt="Image file">
  
<img width=513 height=27 src="img114.gif" alt="Image file">
  
<img width=525 height=29 src="img115.gif" alt="Image file">
  
<P> 
A call to  
<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED(count, B, D, oldtype, newtype)</font>  
is equivalent to a call to  
<font face="sans-serif"> MPI_TYPE_CREATE_STRUCT(count, B, D, T, newtype)</font>,  
where each entry of <font face="sans-serif"> T</font> is equal to <font face="sans-serif"> oldtype</font>.  
<P> 

<P>
<hr>
<a href="node97.htm#Node97"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node96.htm#Node96"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node99.htm#Node99"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node96.htm#Node96"> Derived Datatypes</a>
<b>Next: </b><a href="node99.htm#Node99"> Subarray Datatype Constructor</a>
<b>Previous: </b><a href="node97.htm#Node97"> Type Constructors with Explicit Addresses</a>
<p>
<HR>
Return to <A HREF="node601.htm">MPI-4.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-4.1 of November 2, 2023<BR>
HTML Generated on November 19, 2023
</FONT>
</body>
</html>
