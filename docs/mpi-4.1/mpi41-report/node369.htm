<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-io/io-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi4-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi41-report-html.idx -basedef mpi4defs.txt -o mpi41-report.tex mpi-report.tex 
-->
<title>Data Access with Individual File Pointers</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node369">15.4.3. Data Access with Individual File Pointers</span></h2>
<a href="node368.htm#Node368"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node362.htm#Node362"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node370.htm#Node370"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node362.htm#Node362"> Data Access</a>
<b>Next: </b><a href="node370.htm#Node370"> Data Access with Shared File Pointers</a>
<b>Previous: </b><a href="node368.htm#Node368"> Data Access with Explicit Offsets</a>
<p>
  
  
  
<P> 
<font face="sans-serif"> MPI</font> maintains one individual file pointer  
per process per  
file handle.  
The current value of this pointer implicitly specifies  
the offset in the data access routines described in this section.  
These routines only use and update the individual file pointers  
maintained by <font face="sans-serif"> MPI</font>.  
The shared file pointer is not used nor updated.  
<P> 
The individual file pointer routines  
have the same semantics as the data access with explicit offset routines  
described in Section <a href="node368.htm#Node368">Data Access with Explicit Offsets</a>,  
with the following modification:  
<ul> 
 
<li>the <font face="sans-serif"> offset</font> is defined to be the current value  
        of the <font face="sans-serif"> MPI</font>-maintained individual file pointer.  
</ul> 
<br> 
After an individual file pointer operation is initiated,  
the individual file pointer is updated to point  
to the next etype after the last one   
that will be accessed.  
The file pointer is updated relative to the current view of the file.  
<P> 
If <font face="sans-serif"> MPI_MODE_SEQUENTIAL</font> mode was specified when the file  
was opened, it is erroneous to call the routines in this   
section, with  
the exception of <font face="sans-serif"> MPI_FILE_GET_BYTE_OFFSET</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_READ(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_read(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  
  <tt> int MPI_File_read_c(MPI_File fh, void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_read(fh, buf, count, datatype, status, ierror) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..) :: <span style="white-space:nowrap">buf</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_read(fh, buf, count, datatype, status, ierror) !(_c) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..) :: <span style="white-space:nowrap">buf</span> <br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_READ(FH, BUF, COUNT, DATATYPE, STATUS, IERROR) <br><br>INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">IERROR</span> <br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_READ</font> reads a file using the individual file pointer.  
<P> 
<br><b> Example</b>  
  
  
The following Fortran code fragment is an example of reading  
a file until the end of file is reached:  
<P><img width=821 height=748 src="img408.gif" alt="Image file"><P>
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_READ_ALL(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_read_all(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  
  <tt> int MPI_File_read_all_c(MPI_File fh, void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_read_all(fh, buf, count, datatype, status, ierror) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..) :: <span style="white-space:nowrap">buf</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_read_all(fh, buf, count, datatype, status, ierror) !(_c) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..) :: <span style="white-space:nowrap">buf</span> <br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_READ_ALL(FH, BUF, COUNT, DATATYPE, STATUS, IERROR) <br><br>INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">IERROR</span> <br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_READ_ALL</font> is a collective version  
of the blocking <font face="sans-serif"> MPI_FILE_READ</font> interface.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_WRITE(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_write(MPI_File fh, const void *buf, int count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  
  <tt> int MPI_File_write_c(MPI_File fh, const void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_write(fh, buf, count, datatype, status, ierror) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_write(fh, buf, count, datatype, status, ierror) !(_c) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span> <br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_WRITE(FH, BUF, COUNT, DATATYPE, STATUS, IERROR) <br><br>INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">IERROR</span> <br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_WRITE</font> writes a file using the individual file pointer.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_WRITE_ALL(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_write_all(MPI_File fh, const void *buf, int count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  
  <tt> int MPI_File_write_all_c(MPI_File fh, const void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_write_all(fh, buf, count, datatype, status, ierror) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_write_all(fh, buf, count, datatype, status, ierror) !(_c) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span> <br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_WRITE_ALL(FH, BUF, COUNT, DATATYPE, STATUS, IERROR) <br><br>INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">IERROR</span> <br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_WRITE_ALL</font> is a collective version  
of the blocking <font face="sans-serif"> MPI_FILE_WRITE</font> interface.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_IREAD(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>request object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_iread(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Request *request) <br></tt>  
  
  <tt> int MPI_File_iread_c(MPI_File fh, void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_iread(fh, buf, count, datatype, request, ierror) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_iread(fh, buf, count, datatype, request, ierror) !(_c) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span> <br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_IREAD(FH, BUF, COUNT, DATATYPE, REQUEST, IERROR) <br><br>INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_IREAD</font> is a nonblocking version of the <font face="sans-serif"> MPI_FILE_READ</font> interface.  
<P> 
<br><b> Example</b>  
  
  
The following Fortran code fragment illustrates file pointer  
update semantics:  
<P><img width=821 height=623 src="img409.gif" alt="Image file"><P>
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_IREAD_ALL(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>request object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_iread_all(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Request *request) <br></tt>  
  
  <tt> int MPI_File_iread_all_c(MPI_File fh, void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_iread_all(fh, buf, count, datatype, request, ierror) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_iread_all(fh, buf, count, datatype, request, ierror) !(_c) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span> <br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_IREAD_ALL(FH, BUF, COUNT, DATATYPE, REQUEST, IERROR) <br><br>INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_IREAD_ALL</font> is a nonblocking version  
of <font face="sans-serif"> MPI_FILE_READ_ALL</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_IWRITE(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>request object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_iwrite(MPI_File fh, const void *buf, int count, MPI_Datatype datatype, MPI_Request *request) <br></tt>  
  
  <tt> int MPI_File_iwrite_c(MPI_File fh, const void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_iwrite(fh, buf, count, datatype, request, ierror) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_iwrite(fh, buf, count, datatype, request, ierror) !(_c) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span> <br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_IWRITE(FH, BUF, COUNT, DATATYPE, REQUEST, IERROR) <br><br>INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_IWRITE</font> is a nonblocking version of <font face="sans-serif"> MPI_FILE_WRITE</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_IWRITE_ALL(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>request object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_iwrite_all(MPI_File fh, const void *buf, int count, MPI_Datatype datatype, MPI_Request *request) <br></tt>  
  
  <tt> int MPI_File_iwrite_all_c(MPI_File fh, const void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_iwrite_all(fh, buf, count, datatype, request, ierror) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_iwrite_all(fh, buf, count, datatype, request, ierror) !(_c) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span> <br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_IWRITE_ALL(FH, BUF, COUNT, DATATYPE, REQUEST, IERROR) <br><br>INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_IWRITE_ALL</font> is a nonblocking version  
of <font face="sans-serif"> MPI_FILE_WRITE_ALL</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_SEEK(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">offset</span>, <span style="white-space:nowrap">whence</span>)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> IN offset</TD><TD>file offset (integer)</TD></TR>  
<TR><TD> IN whence</TD><TD>update mode (state)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_seek(MPI_File fh, MPI_Offset offset, int whence) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_seek(fh, offset, whence, ierror) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: <span style="white-space:nowrap">offset</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">whence</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_SEEK(FH, OFFSET, WHENCE, IERROR) <br><br>INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">WHENCE</span>, <span style="white-space:nowrap">IERROR</span> <br>INTEGER(KIND=MPI_OFFSET_KIND) <span style="white-space:nowrap">OFFSET</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_SEEK</font> updates the individual file pointer according to   
<font face="sans-serif"> whence</font>,  
which has the following possible values:  
<P><img width=666 height=131 src="img410.gif" alt="Image file"><P>
The <font face="sans-serif"> offset</font> can be negative, which allows seeking backwards.  
It is erroneous to seek to a negative position in the view.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_GET_POSITION(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">offset</span>)</TD></TR>  
<TR><TD> IN fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> OUT offset</TD><TD>offset of individual pointer (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_get_position(MPI_File fh, MPI_Offset *offset) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_get_position(fh, offset, ierror) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: <span style="white-space:nowrap">offset</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_GET_POSITION(FH, OFFSET, IERROR) <br><br>INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">IERROR</span> <br>INTEGER(KIND=MPI_OFFSET_KIND) <span style="white-space:nowrap">OFFSET</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_GET_POSITION</font> returns, in <font face="sans-serif"> offset</font>,  
the current position of the individual file pointer in etype units  
relative to the current view.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The <font face="sans-serif"> offset</font> can be used in a future call to <font face="sans-serif"> MPI_FILE_SEEK</font>  
using <font face="sans-serif"> whence</font> = <font face="sans-serif"> MPI_SEEK_SET</font> to return to the current position.  
To set the displacement to the current file pointer position,  
first convert <font face="sans-serif"> offset</font> into an absolute byte position using  
<font face="sans-serif"> MPI_FILE_GET_BYTE_OFFSET</font>,  
then call <font face="sans-serif"> MPI_FILE_SET_VIEW</font> with the resulting  
displacement.  
 (<em> End of advice to users.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_GET_BYTE_OFFSET(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">offset</span>, <span style="white-space:nowrap">disp</span>)</TD></TR>  
<TR><TD> IN fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> IN offset</TD><TD>offset (integer)</TD></TR>  
<TR><TD> OUT disp</TD><TD>absolute byte position of offset (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_get_byte_offset(MPI_File fh, MPI_Offset offset, MPI_Offset *disp) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_get_byte_offset(fh, offset, disp, ierror) <br><br>TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span> <br>INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: <span style="white-space:nowrap">offset</span> <br>INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: <span style="white-space:nowrap">disp</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_GET_BYTE_OFFSET(FH, OFFSET, DISP, IERROR) <br><br>INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">IERROR</span> <br>INTEGER(KIND=MPI_OFFSET_KIND) <span style="white-space:nowrap">OFFSET</span>, <span style="white-space:nowrap">DISP</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_GET_BYTE_OFFSET</font> converts a view-relative offset  
into an absolute byte position.  
The absolute byte position (from the beginning of the file)  
of <font face="sans-serif"> offset</font> relative to the current view of <font face="sans-serif"> fh</font>  
is returned in <font face="sans-serif"> disp</font>.  
<P> 

<P>
<hr>
<a href="node368.htm#Node368"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node362.htm#Node362"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node370.htm#Node370"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node362.htm#Node362"> Data Access</a>
<b>Next: </b><a href="node370.htm#Node370"> Data Access with Shared File Pointers</a>
<b>Previous: </b><a href="node368.htm#Node368"> Data Access with Explicit Offsets</a>
<p>
<HR>
Return to <A HREF="node601.htm">MPI-4.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-4.1 of November 2, 2023<BR>
HTML Generated on November 19, 2023
</FONT>
</body>
</html>
