<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi4-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi41-report-html.idx -basedef mpi4defs.txt -o mpi41-report.tex mpi-report.tex 
-->
<title>Matched Receives</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node81">4.8.3. Matched Receives</span></h2>
<a href="node80.htm#Node80"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node78.htm#Node78"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node82.htm#Node82"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node78.htm#Node78"> Probe and Cancel</a>
<b>Next: </b><a href="node82.htm#Node82"> Cancel</a>
<b>Previous: </b><a href="node80.htm#Node80"> Matching Probe</a>
<p>
  
  
  
  
  
<P> 
The <b> matched receive</b> operation (<font face="sans-serif"> MPI_MRECV</font> and <font face="sans-serif"> MPI_IMRECV</font> procedures) receive  
<em> messages</em> that have been previously matched by a <em> matching probe</em> operation  
(Section <a href="node80.htm#Node80">Matching Probe</a>).  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_MRECV(<span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">message</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of receive buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in receive buffer (non-negative integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each receive buffer element (handle)</TD></TR>  
<TR><TD> INOUT message</TD><TD>message (handle)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Mrecv(void *buf, int count, MPI_Datatype datatype, MPI_Message *message, MPI_Status *status) <br></tt>  
  
  <tt> int MPI_Mrecv_c(void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Message *message, MPI_Status *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Mrecv(buf, count, datatype, message, status, ierror) <br><br>TYPE(*), DIMENSION(..) :: <span style="white-space:nowrap">buf</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Message), INTENT(INOUT) :: <span style="white-space:nowrap">message</span> <br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Mrecv(buf, count, datatype, message, status, ierror) !(_c) <br><br>TYPE(*), DIMENSION(..) :: <span style="white-space:nowrap">buf</span> <br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Message), INTENT(INOUT) :: <span style="white-space:nowrap">message</span> <br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_MRECV(BUF, COUNT, DATATYPE, MESSAGE, STATUS, IERROR) <br><br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">MESSAGE</span>, <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
This call receives a message matched by a <em> matching probe</em> operation  
(Section <a href="node80.htm#Node80">Matching Probe</a>).  
<P> 
The <em> receive buffer</em> consists of the storage containing <font face="sans-serif"> count</font>  
consecutive elements of the type specified by <font face="sans-serif"> datatype</font>,  
starting at address <font face="sans-serif"> buf</font>.  
The length of the received message  
must be less than or equal to the length of the receive buffer. An  
overflow error occurs if all incoming data does not fit, without  
truncation, into the receive buffer.  
<P> 
If the message is shorter than the receive buffer, then only those  
locations corresponding to the (shorter) message are modified.  
<P> 
On return from this function, the <em> message handle</em> is set to  
<font face="sans-serif"> MPI_MESSAGE_NULL</font>. All errors that occur during the execution of  
this operation are handled according to the error handler set for the  
communicator used in the matching probe call that produced the message  
handle.  
<P> 
If <font face="sans-serif"> MPI_MRECV</font> is called with  
<font face="sans-serif"> MPI_MESSAGE_NO_PROC</font>  
as the  
message argument, the call returns immediately with the status object  
set to <font face="sans-serif"> source</font><font face="sans-serif">  = </font><font face="sans-serif"> MPI_PROC_NULL</font>, <font face="sans-serif"> tag</font><font face="sans-serif">  = </font><font face="sans-serif"> MPI_ANY_TAG</font>, and  
<font face="sans-serif"> count</font><font face="sans-serif">  = 0</font>.  
This is consistent with the status object produced by  
a call to <font face="sans-serif"> MPI_RECV</font> or to <font face="sans-serif"> MPI_PROBE</font>  
with <font face="sans-serif"> source</font><font face="sans-serif">  = </font><font face="sans-serif"> MPI_PROC_NULL</font>  
(see Section <a href="node84.htm#Node84">Null <font face="sans-serif"> MPI</font> Processes</a>).  
A call to <font face="sans-serif"> MPI_MRECV</font> with <font face="sans-serif"> MPI_MESSAGE_NULL</font> is <em> erroneous</em>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_IMRECV(<span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">message</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of receive buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in receive buffer (non-negative integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each receive buffer element (handle)</TD></TR>  
<TR><TD> INOUT message</TD><TD>message (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Imrecv(void *buf, int count, MPI_Datatype datatype, MPI_Message *message, MPI_Request *request) <br></tt>  
  
  <tt> int MPI_Imrecv_c(void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Message *message, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Imrecv(buf, count, datatype, message, request, ierror) <br><br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Message), INTENT(INOUT) :: <span style="white-space:nowrap">message</span> <br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Imrecv(buf, count, datatype, message, request, ierror) !(_c) <br><br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span> <br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span> <br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span> <br>TYPE(MPI_Message), INTENT(INOUT) :: <span style="white-space:nowrap">message</span> <br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_IMRECV(BUF, COUNT, DATATYPE, MESSAGE, REQUEST, IERROR) <br><br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">MESSAGE</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_IMRECV</font> is the nonblocking variant of <font face="sans-serif"> MPI_MRECV</font>  
and starts a nonblocking receive of a matched message. Completion  
semantics are similar to <font face="sans-serif"> MPI_IRECV</font> as described in  
Section <a href="node73.htm#Node73">Communication Initiation</a>. On return from this function,  
the <em> message handle</em> is set to <font face="sans-serif"> MPI_MESSAGE_NULL</font>.  
<P> 
If <font face="sans-serif"> MPI_IMRECV</font> is called with <font face="sans-serif"> MPI_MESSAGE_NO_PROC</font>  
as the message argument, the call returns immediately with a request  
object that, when completed, will yield a status object set to  
<font face="sans-serif"> source</font><font face="sans-serif">  = </font><font face="sans-serif"> MPI_PROC_NULL</font>, <font face="sans-serif"> tag</font><font face="sans-serif">  = </font><font face="sans-serif"> MPI_ANY_TAG</font>,  
and <font face="sans-serif"> count</font><font face="sans-serif">  = 0</font>, as if a receive from <font face="sans-serif"> MPI_PROC_NULL</font>  
was issued (see Section <a href="node84.htm#Node84">Null <font face="sans-serif"> MPI</font> Processes</a>).  
A call to <font face="sans-serif"> MPI_IMRECV</font> with <font face="sans-serif"> MPI_MESSAGE_NULL</font> is <em> erroneous</em>.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
If reception of a matched message is started with  
<font face="sans-serif"> MPI_IMRECV</font>, then it is possible to <em> cancel</em> the returned  
request with <font face="sans-serif"> MPI_CANCEL</font>. If <font face="sans-serif"> MPI_CANCEL</font> succeeds, the  
matched message must be found by a subsequent message probe  
(<font face="sans-serif"> MPI_PROBE</font>, <font face="sans-serif"> MPI_IPROBE</font>, <font face="sans-serif"> MPI_MPROBE</font>, or  
<font face="sans-serif"> MPI_IMPROBE</font>), received by a subsequent receive operation or  
<em> cancelled</em> by the sender.  
See Section <a href="node82.htm#Node82">Cancel</a> for details about <font face="sans-serif"> MPI_CANCEL</font>.  
The <em> cancellation</em> of operations initiated with <font face="sans-serif"> MPI_IMRECV</font> may  
fail.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node80.htm#Node80"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node78.htm#Node78"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node82.htm#Node82"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node78.htm#Node78"> Probe and Cancel</a>
<b>Next: </b><a href="node82.htm#Node82"> Cancel</a>
<b>Previous: </b><a href="node80.htm#Node80"> Matching Probe</a>
<p>
<HR>
Return to <A HREF="node601.htm">MPI-4.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-4.1 of November 2, 2023<BR>
HTML Generated on November 19, 2023
</FONT>
</body>
</html>
