<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-one-side/one-side-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi4-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi41-report-html.idx -basedef mpi4defs.txt -o mpi41-report.tex mpi-report.tex 
-->
<title>Lock</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node330">13.5.3. Lock</span></h2>
<a href="node329.htm#Node329"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node327.htm#Node327"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node331.htm#Node331"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node327.htm#Node327"> Synchronization Calls</a>
<b>Next: </b><a href="node331.htm#Node331"> Flush and Sync</a>
<b>Previous: </b><a href="node329.htm#Node329"> General Active Target Synchronization</a>
<p>
  
<P> 
Locks are used to protect accesses to the locked target  
window effected by <font face="sans-serif"> RMA</font> calls issued between the lock and unlock  
calls, and to protect  
load/store accesses to a locked local or shared  
memory window executed between the lock and unlock  
calls.  
Accesses that are protected by an <b> exclusive lock</b> (acquired using <font face="sans-serif"> MPI_LOCK_EXCLUSIVE</font>)  
will not be concurrent at the window site  
with other accesses to the same window that are lock protected.  
Accesses that are protected by a <b> shared lock</b> (acquired using <font face="sans-serif"> MPI_LOCK_SHARED</font>) will not be  
concurrent at the window site with  
accesses protected by an <em> exclusive lock</em> to the same window.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_LOCK(<span style="white-space:nowrap">lock_type</span>, <span style="white-space:nowrap">rank</span>, <span style="white-space:nowrap">assert</span>, <span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD> IN lock_type</TD><TD>either <font face="sans-serif"> MPI_LOCK_EXCLUSIVE</font> or <font face="sans-serif"> MPI_LOCK_SHARED</font> (state)</TD></TR>  
<TR><TD> IN rank</TD><TD>rank of locked window (non-negative integer)</TD></TR>  
<TR><TD> IN assert</TD><TD>program assertion (integer)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Win_lock(int lock_type, int rank, int assert, MPI_Win win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Win_lock(lock_type, rank, assert, win, ierror) <br><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">lock_type</span>, <span style="white-space:nowrap">rank</span>, <span style="white-space:nowrap">assert</span> <br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WIN_LOCK(LOCK_TYPE, RANK, ASSERT, WIN, IERROR) <br><br>INTEGER <span style="white-space:nowrap">LOCK_TYPE</span>, <span style="white-space:nowrap">RANK</span>, <span style="white-space:nowrap">ASSERT</span>, <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Opens an <font face="sans-serif"> RMA</font> access epoch.  
The  
window at the  
<font face="sans-serif"> MPI</font> process with a rank of <font face="sans-serif"> rank</font> in the group of <font face="sans-serif"> win</font> can be accessed by <font face="sans-serif"> RMA</font> operations  
on <font face="sans-serif"> win</font> during that  
epoch.  
Multiple <font face="sans-serif"> RMA</font> access epochs (with calls to <font face="sans-serif"> MPI_WIN_LOCK</font>)  
can occur simultaneously; however, each access epoch must target a  
different <font face="sans-serif"> MPI</font> process.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_LOCK_ALL(<span style="white-space:nowrap">assert</span>, <span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD> IN assert</TD><TD>program assertion (integer)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Win_lock_all(int assert, MPI_Win win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Win_lock_all(assert, win, ierror) <br><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">assert</span> <br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WIN_LOCK_ALL(ASSERT, WIN, IERROR) <br><br>INTEGER <span style="white-space:nowrap">ASSERT</span>, <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Opens an <font face="sans-serif"> RMA</font> access epoch to all <font face="sans-serif"> MPI</font> processes in  
<font face="sans-serif"> win</font>, with a lock type of <font face="sans-serif"> MPI_LOCK_SHARED</font>.   
During the epoch, the calling <font face="sans-serif"> MPI</font> process can access the window memory on all  
<font face="sans-serif"> MPI</font> processes in <font face="sans-serif"> win</font> by using <font face="sans-serif"> RMA</font> operations. A window locked with  
<font face="sans-serif"> MPI_WIN_LOCK_ALL</font> must be unlocked with  
<font face="sans-serif"> MPI_WIN_UNLOCK_ALL</font>.  This routine is not collective---the  
<font face="sans-serif"> ALL</font> refers to a lock on all members of the group of the window.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
There may be additional overheads associated with using  
<font face="sans-serif"> MPI_WIN_LOCK</font> and <font face="sans-serif"> MPI_WIN_LOCK_ALL</font> concurrently  
on the same window. These overheads could be avoided by specifying the  
assertion <font face="sans-serif"> MPI_MODE_NOCHECK</font> when possible (see  
Section <a href="node332.htm#Node332">Assertions</a>).  
 (<em> End of advice to users.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_UNLOCK(<span style="white-space:nowrap">rank</span>, <span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD> IN rank</TD><TD>rank of window (non-negative integer)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Win_unlock(int rank, MPI_Win win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Win_unlock(rank, win, ierror) <br><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">rank</span> <br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WIN_UNLOCK(RANK, WIN, IERROR) <br><br>INTEGER <span style="white-space:nowrap">RANK</span>, <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Closes an <font face="sans-serif"> RMA</font> access epoch opened by a call to  
<font face="sans-serif"> MPI_WIN_LOCK</font> on window <font face="sans-serif"> win</font>.  
<font face="sans-serif"> RMA</font> operations issued during this  
period will have completed both at the origin and at the target when the call returns.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_UNLOCK_ALL(<span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Win_unlock_all(MPI_Win win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Win_unlock_all(win, ierror) <br><br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WIN_UNLOCK_ALL(WIN, IERROR) <br><br>INTEGER <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Closes a shared <font face="sans-serif"> RMA</font> access epoch opened by a call to  
<font face="sans-serif"> MPI_WIN_LOCK_ALL</font> on window <font face="sans-serif"> win</font>.  
<font face="sans-serif"> RMA</font> operations issued during this  
epoch will have completed both at the origin and at the target when the call returns.  
<P> 
  
It is erroneous to have a window locked and exposed (in an exposure  
epoch) concurrently.  For example, an <font face="sans-serif"> MPI</font> process may not call  
<font face="sans-serif"> MPI_WIN_LOCK</font> to lock a target window if the target process  
has called <font face="sans-serif"> MPI_WIN_POST</font> and has not yet called  
<font face="sans-serif"> MPI_WIN_WAIT</font>; it is erroneous to call  
<font face="sans-serif"> MPI_WIN_POST</font> while the local window is locked.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
An alternative is to require <font face="sans-serif"> MPI</font> to enforce mutual exclusion between exposure epochs and locking periods.  But this would entail additional  
overheads when locks or active target synchronization do not interact  
in support of those rare interactions between the two mechanisms.  The  
programming style that we encourage here is that a set of windows is  
used with only one synchronization mechanism at a time, with shifts  
from one mechanism to another being rare and involving global synchronization.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Users need to use explicit synchronization code in order to enforce  
mutual exclusion between locking periods and exposure epochs on a  
window.  
 (<em> End of advice to users.</em>) <br> 
Implementors may restrict the use of <font face="sans-serif"> RMA</font> communication that is   
synchronized by lock calls to windows in memory allocated by   
<font face="sans-serif"> MPI_ALLOC_MEM</font>   
(Section <a href="node251.htm#Node251">Memory Allocation</a>),  
<font face="sans-serif"> MPI_WIN_ALLOCATE</font> (Section <a href="node310.htm#Node310">Window That Allocates Memory</a>),  
<font face="sans-serif"> MPI_WIN_ALLOCATE_SHARED</font> (Section <a href="node311.htm#Node311">Window That Allocates Shared Memory</a>), or attached with  
<font face="sans-serif"> MPI_WIN_ATTACH</font> (Section <a href="node312.htm#Node312">Window of Dynamically Attached Memory</a>).  
Locks can be used portably only in such memory.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The implementation of passive target communication between processes in different <em> shared memory domains</em>  
may require an asynchronous software   
agent.  Such an agent can be implemented more easily, and can achieve  
better performance, if restricted to specially allocated memory.  It  
can be avoided altogether if <em> shared memory</em> is used. It seems natural to  
impose restrictions that allow the use of shared memory for  
<font face="sans-serif"> RMA</font> communication in shared memory machines.  
<P> 
 (<em> End of rationale.</em>) <br> 
Consider the sequence of calls in the example below.  
<br><b> Example</b>  
Use of <font face="sans-serif"> MPI_WIN_LOCK</font> and <font face="sans-serif"> MPI_WIN_UNLOCK</font>.  
<P><img width=729 height=75 src="img380.gif" alt="Image file"><P>
The call to <font face="sans-serif"> MPI_WIN_UNLOCK</font> will not return until the put  
transfer has completed at the origin  
and at the target.  
  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The semantics described above still leave much freedom to implementors.  
Return from the call to  
<font face="sans-serif"> MPI_WIN_LOCK</font> may be delayed until an  
exclusive lock on the window is acquired; or, the first  
two calls may return immediately, while return from <font face="sans-serif"> MPI_WIN_UNLOCK</font> is delayed until  
a lock is acquired---the update of the target window is then  
postponed until the call to <font face="sans-serif"> MPI_WIN_UNLOCK</font> occurs.  
However,  if the call to <font face="sans-serif"> MPI_WIN_LOCK</font> is used to lock a  
window accessible via load/store accesses (i.e., a local window or a window at an <font face="sans-serif"> MPI</font> process  
for which a pointer to shared memory can be obtained via <font face="sans-serif"> MPI_WIN_SHARED_QUERY</font>),  
then the call must not return before the lock is acquired,  
since the lock may protect load/store accesses to the window issued  
after the lock call returns.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
In order to ensure a portable deadlock free program, a user must assume  
that <font face="sans-serif"> MPI_WIN_LOCK</font> may delay its return until the desired lock on the  
window has been acquired.  
 (<em> End of advice to users.</em>) <br> 

<P>
<hr>
<a href="node329.htm#Node329"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node327.htm#Node327"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node331.htm#Node331"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node327.htm#Node327"> Synchronization Calls</a>
<b>Next: </b><a href="node331.htm#Node331"> Flush and Sync</a>
<b>Previous: </b><a href="node329.htm#Node329"> General Active Target Synchronization</a>
<p>
<HR>
Return to <A HREF="node601.htm">MPI-4.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-4.1 of November 2, 2023<BR>
HTML Generated on November 19, 2023
</FONT>
</body>
</html>
